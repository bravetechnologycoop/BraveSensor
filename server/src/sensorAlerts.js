/*
 * sensorAlerts.js
 *
 * Handles all types of alerts generated by device firmware
 * Alerts and sensor events are recieved via particle webhooks on /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')

// In-house dependencies
const { helpers, twilioHelpers, SENSOR_EVENT, ALERT_TYPE } = require('brave-alert-lib')
const db = require('./db/db')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')

async function handleAlert(location, alertType, alertData) {
  let pgClient

  try {
    pgClient = await db.beginTransaction()
    if (pgClient === null) {
      helpers.logError(`handleAlert: Error starting transaction`)
      return
    }

    /*
      CREATE TABLE Sessions (
          id              UUID        PRIMARY KEY DEFAULT uuid_generate_v4(),
          device_id       UUID        NOT NULL REFERENCES Devices(id),
          updated_at      TIMESTAMP   NOT NULL,
          door_closed_at  TIMESTAMP   NOT NULL,
          door_opened_at  TIMESTAMP,
      );
      CREATE TABLE Alerts (
          id              UUID        PRIMARY KEY DEFAULT uuid_generate_v4(),
          session_id      UUID        NOT NULL REFERENCES Sessions(id),
          alert_type      ENUM        NOT NULL,
          recieved_at     TIMESTAMP   NOT NULL,
      );
    */

    // time when this current alert was recieved
    const currentTime = await db.getCurrentTime(pgClient)

    // check if a session already exists for the device
    const currentSession = await db.getSessionWithDeviceId(location.id, pgClient)

    // client
    const client = location.client

    // if there is no session, then this is the first alert
    if (currentSession === null) {
      // create new session
      const newSession = await db.createSession(
        location.id, // device_id foriegn key
        currentTime, // updated_at
        alertData.timeWhenDoorClosed, // door_closed_at
        pgClient, // pg database instance
      )

      // push the alert to the alerts table
      await db.createAlert(
        newSession.id, // foriegn key session id
        alertType, // alert type
        currentTime, // recieved_at
        pgClient, // pg database instance
      )

      // based on the type of alert, identify the initial message to sent
      // make sure to translate the alert message here as well
      // if a duration alert recieved, send the duration alert message: {location} has been occupied for {alertData.occupancyTime} minutes
      // if a initial stillness alert is recieved, send the message: {location} needs a SAFETY CHECK. On your way? Reply with anything
      // the door opened type alert cannot be recieved as the first alert so error
      let textMessage = ''
      if (alertType === ALERT_TYPE.SENSOR_DURATION) {
        textMessage = `${location.displayName} has been occupied for ${alertData.occupancyTime} minutes`
      } else if (alertType === ALERT_TYPE.SENSOR_STILLNESS) {
        textMessage = `${location.displayName} needs a SAFETY CHECK. On your way? Reply with anything`
      } else {
        helpers.logError('Invalid alert type received as the first alert')
      }

      // send message to all responder phone numbers
      let response
      try {
        const fromPhoneNumber = location.fromPhoneNumber
        const responderPhoneNumbers = client.responderPhoneNumbers
        const hasValidPhoneNumbers = fromPhoneNumber && responderPhoneNumbers && responderPhoneNumbers.length > 0

        if (hasValidPhoneNumbers) {
          const messagePromises = responderPhoneNumbers.map(toPhoneNumber =>
            twilioHelpers.sendTwilioMessage(toPhoneNumber, fromPhoneNumber, textMessage),
          )
          response = await Promise.all(messagePromises)
        }
      } catch (error) {
        helpers.logError(error)
      }

      // handle invalid response (all promises are resolved)
      const isResponseInvalid = response === undefined || (Array.isArray(response) && response.every(result => result === undefined))
      if (isResponseInvalid) {
        helpers.logError(`Failed to send alert update for session ${newSession.id}: ${textMessage}`)
      }
    }
    // otherwise, the session already exist
    else {
      // if the alert recived was a door opened alert,
      // then update the session door_opened_at to current time

      if (alertType === SENSOR_EVENT.DOOR_OPENED) {
        // update the existing session
        await db.updateSession(
          currentSession.id, // session will be identified by this
          currentTime, // updated_at
          currentTime, // door_opened_at
          pgClient, // pg database instance
        )
      } else {
        // otherwise if it was another duration or stillness alert
        // update the existing session
        await db.updateSession(
          currentSession.id, // session will be identified by this
          currentTime, // updated_at
          pgClient, // pg database instance
        )
      }

      // push the alert to the alerts table
      await db.createAlert(
        currentSession.id, // foriegn key session id
        alertType, // alert type
        currentTime, // recieved_at
        pgClient, // pg database instance
      )
    }

    await db.commitTransaction(pgClient)
  } catch (e) {
    try {
      await db.rollbackTransaction(pgClient)
      helpers.logError(`handleAlert: Rolled back transaction because of error: ${e}`)
    } catch (error) {
      // Do nothing
      helpers.logError(`handleAlert: Error rolling back transaction: ${error} Rollback attempted because of error: ${e}`)
    }
  }
}

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)

    if (validationErrors.isEmpty()) {
      const apiKey = request.body.api_key

      if (particleWebhookAPIKey === apiKey) {
        const sensorEvent = request.body.event
        const alertData = request.body.data
        const coreId = request.body.coreid

        let alertType
        if (sensorEvent === SENSOR_EVENT.DURATION) {
          alertType = ALERT_TYPE.SENSOR_DURATION
        } else if (sensorEvent === SENSOR_EVENT.STILLNESS) {
          alertType = ALERT_TYPE.SENSOR_STILLNESS
        } else {
          const errorMessage = `Bad request to ${request.path}: Invalid event type`
          helpers.logError(errorMessage)
        }

        const location = await db.getDeviceWithSerialNumber(coreId)
        if (!location) {
          const errorMessage = `Bad request to ${request.path}: no location matches the coreID ${coreId}`
          helpers.logError(errorMessage)
          // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
          response.status(200).json(errorMessage)
        } else {
          if (location.client.isSendingAlerts && location.isSendingAlerts) {
            await handleAlert(location, alertType, alertData)
          }
          response.status(200).json('OK')
        }
      } else {
        const errorMessage = `Access not allowed`
        helpers.logError(errorMessage)
        // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
        response.status(200).json(errorMessage)
      }
    } else {
      const errorMessage = `Bad request to ${request.path}: ${validationErrors.array()}`
      helpers.logError(errorMessage)
      // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
      response.status(200).json(errorMessage)
    }
  } catch (err) {
    const errorMessage = `Error calling ${request.path}: ${err.toString()}`
    helpers.logError(errorMessage)
    // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
    response.status(200).json(errorMessage)
  }
}

module.exports = {
  validateSensorEvent,
  handleSensorEvent,
}
