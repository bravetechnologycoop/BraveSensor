/*
 * sensorEvents.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE } = require('./enums/index')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')
const STILLNESS_ALERT_REMINDER = helpers.getEnvVar('STILLNESS_ALERT_REMINDER')

// ----------------------------------------------------------------------------------------------------------------------------

async function handleStillnessFallbackAlert(client, device) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      throw new Error('Error starting transaction')
    }

    // Re-fetch latest session state to ensure consistency
    const currentSession = await db_new.getLatestActiveSessionWithDeviceId(device.deviceId, pgClient)

    // Only send fallback if session has not been responded to and the door is closed
    // Otherwise exit here
    if (currentSession.attendingResponderNumber || currentSession.doorOpened) return

    const messageKey = 'stillnessAlertFallback'
    const textMessage = i18next.t(messageKey, {
      lng: client.language || 'en',
      deviceDisplayName: device.displayName,
    })

    // Log the event and send message to fallback numbers only
    await db_new.createEvent(currentSession.sessionId, EVENT_TYPE.STILLNESS_ALERT, messageKey, pgClient)
    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, client.fallbackPhoneNumbers, textMessage)

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        throw new Error(`Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
      }
    }
    throw new Error(`handleStillnessFallbackAlert: ${error}`)
  }
}

async function handleStillnessAlertReminder(client, device, reminderNumber) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      throw new Error('Error starting transaction')
    }

    const currentSession = await db_new.getLatestActiveSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) throw new Error(`No active session found for device ID: ${device.deviceId}`)

    // Only send reminders if session has not been responded to and the door is closed
    // Otherwise exit here
    if (currentSession.attendingResponderNumber || currentSession.doorOpened) return

    const messageKey = reminderNumber === 1 ? 'stillnessAlertFirstReminder' : 'stillnessAlertSecondReminder'
    const textMessage = i18next.t(messageKey, {
      lng: client.language || 'en',
      deviceDisplayName: device.displayName,
    })

    // log the event and send the message to all responders
    await db_new.createEvent(currentSession.sessionId, EVENT_TYPE.STILLNESS_ALERT, messageKey, pgClient)
    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, client.responderPhoneNumbers, textMessage)

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        throw new Error(`Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
      }
    }
    throw new Error(`handleStillnessAlertReminder: ${error}`)
  }
}

async function scheduleStillnessAlerts(client, device) {
  const reminderTimeout = STILLNESS_ALERT_REMINDER * 60 * 1000

  const alertSequence = [
    {
      name: 'First Reminder',
      handler: () => handleStillnessAlertReminder(client, device, 1),
      delay: reminderTimeout,
    },
    {
      name: 'Second Reminder',
      handler: () => handleStillnessAlertReminder(client, device, 2),
      delay: reminderTimeout * 2,
    },
    {
      name: 'Fallback Alert',
      handler: () => handleStillnessFallbackAlert(client, device),
      delay: reminderTimeout * 3,
    },
  ]

  // Execute alerts with proper transaction handling
  async function executeAlert(alert) {
    return new Promise(resolve => {
      setTimeout(async () => {
        let pgClient
        try {
          pgClient = await db_new.beginTransaction()
          if (!pgClient) {
            throw new Error(`Failed to start transaction for ${alert.name}`)
          }

          await alert.handler()
          await db_new.commitTransaction(pgClient)
          resolve()
        } catch (error) {
          if (pgClient) {
            try {
              await db_new.rollbackTransaction(pgClient)
            } catch (rollbackError) {
              helpers.logError(`Error rolling back ${alert.name}: ${rollbackError}`)
            }
          }
          helpers.logError(`Error in ${alert.name}: ${error.message}`)
          resolve() // Still resolve to continue sequence
        }
      }, alert.delay)
    })
  }

  // Execute sequentially but ensure transaction cleanup
  for (const alert of alertSequence) {
    await executeAlert(alert)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

function selectMessageKeyForNewSession(eventType) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'stillnessAlert'
    default: {
      throw new Error(`selectMessageKeyForNewSession: Invalid event type received as the first alert: ${eventType}`)
    }
  }
}

async function selectMessageKeyForExistingSession(eventType, currentSession, pgClient) {
  try {
    switch (eventType) {
      case EVENT_TYPE.DURATION_ALERT:
        return 'durationAlert'
      case EVENT_TYPE.STILLNESS_ALERT:
        return 'stillnessAlert'
      case EVENT_TYPE.DOOR_OPENED: {
        const latestAlertEvent = await db_new.getLatestAlertEvent(currentSession.sessionId, pgClient)
        if (!latestAlertEvent) {
          throw new Error(`No latest alert event found for session ID: ${currentSession.sessionId}`)
        }

        switch (latestAlertEvent.eventType) {
          case EVENT_TYPE.DURATION_ALERT:
            return 'durationAlertSurveyPromptDoorOpened'
          case EVENT_TYPE.STILLNESS_ALERT:
            return 'stillnessAlertSurveyDoorOpened'
          default: {
            throw new Error(`Invalid latest alert event type: ${latestAlertEvent.eventType}`)
          }
        }
      }
      default: {
        throw new Error(`Invalid event type: ${eventType}`)
      }
    }
  } catch (error) {
    throw new Error(`selectMessageKeyForExistingSession: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

async function handleNewSession(client, device, eventType, eventData, pgClient) {
  try {
    // find the message key
    const messageKey = selectMessageKeyForNewSession(eventType)

    // construct the translated text message using message key
    const textMessage = i18next.t(messageKey, {
      lng: client.language || 'en',
      deviceDisplayName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
    })

    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession) {
      throw new Error(`Failed to create a new session`)
    }

    // trigger the reminder cycle if the alert is a stillness alert
    if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      scheduleStillnessAlerts(client, device)
    }

    // log the event and send the message to all responders
    await db_new.createEvent(newSession.sessionId, eventType, messageKey, pgClient)
    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, client.responderPhoneNumbers, textMessage)
  } catch (error) {
    throw new Error(`handleNewSession: Error handling new session for device ID: ${device.deviceId} - ${error.message}`)
  }
}

async function handleExistingSession(client, device, eventType, eventData, currentSession, pgClient) {
  // if an alert is published to an existing active session after the door was opened
  // it means that the alert was triggered by a different occupant afterwards
  // in that case, discard the session and create a new one
  if (currentSession.doorOpened) {
    helpers.log(`Received sensor event for an existing session after door opened, creating new session`)
    await handleNewSession(client, device, eventType, eventData, pgClient)
    return
  }

  try {
    // find the message key
    const messageKey = await selectMessageKeyForExistingSession(eventType, currentSession, pgClient)

    // construct the translated text message using message key
    const surveyCategoriesForMessage = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
    const textMessage = i18next.t(messageKey, {
      lng: client.language || 'en',
      deviceDisplayName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
      surveyCategoriesForMessage,
    })

    // if door opened, update the session
    if (eventType === EVENT_TYPE.DOOR_OPENED) {
      await db_new.updateSession(currentSession.sessionId, currentSession.sessionStatus, true, currentSession.surveySent, pgClient)
    }

    // trigger the reminder and fallback chain if the alert is a stillness alert
    if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      scheduleStillnessAlerts(client, device)
    }

    // If survey was already sent and person responsed with 'Occupant Okay',
    // send the message to only the attending responder and log the event
    // otherwise send message to all responders and log the event
    if (eventType === EVENT_TYPE.DOOR_OPENED && currentSession.surveySent) {
      return
    }
    if (currentSession.attendingResponderNumber && currentSession.surveySent && currentSession.selectedSurveyCategory === 'Occupant Okay') {
      await db_new.createEvent(currentSession.sessionId, EVENT_TYPE.MSG_SENT, messageKey, pgClient)
      await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, currentSession.attendingResponderNumber, textMessage)
    } else {
      await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
      await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, client.responderPhoneNumbers, textMessage)
    }
  } catch (error) {
    throw new Error(`handleExistingSession: Error handling existing session with session ID ${currentSession.sessionId}: ${error.message}`)
  }
}

async function processSensorEvent(client, device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      throw new Error('Error starting transaction')
    }

    // A sensor cannot send more than one stillnessAlert
    if (eventData.numStillnessAlertsSent > 1) {
      throw new Error(`More than one stillness alert received for device: ${device.deviceId}`)
    }

    // A session is finished only if its session_status is COMPLETED and door_opened is true.
    // Ever other session is considered as an "active" session and should be selected here.
    // Those are (status, doorOpened) --> (ACTIVE, true), (ACTIVE, false), (COMPLETED, false)
    const currentSession = await db_new.getLatestActiveSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) {
      await handleNewSession(client, device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(client, device, eventType, eventData, currentSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        throw new Error(`Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
      }
    }
    throw new Error(`processSensorEvent: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Events (/api/sensorEvent)

const validateSensorEvent = [
  Validator.body('event')
    .exists()
    .isString()
    .custom(value => {
      const validEvents = ['Duration Alert', 'Stillness Alert', 'Door Opened']
      return validEvents.includes(value)
    }),
  Validator.body('data').exists().isString(),
  Validator.body('coreid').exists().isString(),
  Validator.body('api_key').exists().isString(),
]

function parseSensorEventType(receivedEventType) {
  const eventTypeMapping = {
    'Duration Alert': EVENT_TYPE.DURATION_ALERT,
    'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
    'Door Opened': EVENT_TYPE.DOOR_OPENED,
  }
  const eventType = eventTypeMapping[receivedEventType]
  if (!eventType) throw new Error(`Unknown event type: ${receivedEventType}`)
  return eventType
}

function parseSensorEventData(receivedEventData) {
  const eventData = typeof receivedEventData === 'string' ? JSON.parse(receivedEventData) : receivedEventData
  if (!eventData) throw new Error('Error parsing event data')

  const requiredFields = {
    alertSentFromState: 'number',
    numDurationAlertsSent: 'number',
    numStillnessAlertsSent: 'number',
    occupancyDuration: 'number',
  }

  for (const [field] of Object.entries(requiredFields)) {
    if (!(field in eventData)) {
      throw new Error(`Missing required field: ${field}`)
    }
    if (typeof eventData[field] !== 'number') {
      throw new Error(`Invalid type for ${field}: expected number, got ${typeof eventData[field]}`)
    }
  }

  return eventData
}

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      throw new Error(`Bad request: ${validationErrors.array()}`)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body
    if (api_key !== particleWebhookAPIKey) throw new Error('Access not allowed: Invalid API key')

    const eventType = parseSensorEventType(receivedEventType)
    const eventData = parseSensorEventData(receivedEventData)

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) throw new Error(`No device matches the coreID: ${particleDeviceID}`)

    const client = await db_new.getClientWithClientId(device.clientId)
    if (!client) throw new Error(`No client found for device: ${device.deviceId}`)

    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      await processSensorEvent(client, device, eventType, eventData)
    }

    response.status(200).json('OK')
  } catch (error) {
    helpers.logError(`Error on ${request.path}: ${error.message}`)
    // Must send 200 so as not to be throttled by Particle
    response.status(200).json(error.message)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

module.exports = {
  validateSensorEvent,
  handleSensorEvent,
}
