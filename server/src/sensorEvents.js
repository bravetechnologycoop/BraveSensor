/*
 * sensorEvents.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')

// In-house dependencies
const helpers = require('./utils/helpers')
const twilioHelpers = require('./utils/twilioHelpers')
const teamsHelpers = require('./utils/teamsHelpers')
const db_new = require('./db/db_new')
const { EVENT_TYPE, SESSION_STATUS, SERVICES } = require('./enums/index')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')
const stillnessReminderinSeconds = helpers.getEnvVar('STILLNESS_ALERT_REMINDER')

// ----------------------------------------------------------------------------------------------------------------------------

async function sendTwilioReminder(session, twilioMessageKey, client, device) {
  if (!session || !session.sessionId || !twilioMessageKey || !client || !client.responderPhoneNumbers || !device) {
    throw new Error(`sendTwilioReminder: Missing required parameters`)
  }

  try {
    const textMessage = helpers.translateMessageKeyToMessage(twilioMessageKey, client, device)
    const targetNumbers = session.attendingResponderNumber || client.responderPhoneNumbers

    if (!targetNumbers || (Array.isArray(targetNumbers) && targetNumbers.length === 0)) {
      helpers.log(`Skipping Twilio alert ${twilioMessageKey} for session ${session.sessionId}: No target phone numbers found.`)
      return
    }

    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, targetNumbers, textMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.STILLNESS_ALERT, twilioMessageKey, targetNumbers)
  } catch (error) {
    throw new Error(`sendTwilioReminder: ${error.message}`)
  }
}

async function sendTeamsReminder(session, teamsMessageKey, client, device) {
  if (!session || !session.sessionId || !teamsMessageKey || !client || !device) {
    throw new Error(`sendTeamsReminder: Missing required parameters`)
  }

  if (!client.teamsId || !client.teamsAlertChannelId) {
    helpers.log(`Skipping Teams update for session ${session.sessionId}: Teams not configured for client ${client.clientId}`)
    return
  }

  try {
    const cardType = 'New'
    const adaptiveCard = teamsHelpers.createAdaptiveCard(teamsMessageKey, cardType, client, device)
    if (!adaptiveCard) {
      throw new Error(`Failed to create adaptive card for teams event: ${teamsMessageKey}`)
    }

    const response = await teamsHelpers.sendNewTeamsCard(client.teamsId, client.teamsAlertChannelId, adaptiveCard, session)
    if (!response || !response.messageId) {
      throw new Error(`Failed to send new Teams card or invalid response received for session ${session.sessionId}`)
    }

    await db_new.createTeamsEvent(session.sessionId, EVENT_TYPE.STILLNESS_ALERT, teamsMessageKey, response.messageId)
  } catch (error) {
    throw new Error(`sendTeamsReminder: ${error.message}`)
  }
}

async function handleStillnessReminder(reminderNumber, session, client, device, sessionId) {
  try {
    const reminderTypeMap = { 1: 'First', 2: 'Second', 3: 'Third' }
    const reminderTypeText = reminderTypeMap[reminderNumber]
    if (!reminderTypeText) return

    const twilioMessageKey = `stillnessAlert${reminderTypeText}Reminder`
    const teamsMessageKey = `teamsStillnessAlert${reminderTypeText}Reminder`

    const messagingPromises = []

    if (!session.sessionRespondedVia) {
      messagingPromises.push(
        sendTwilioReminder(session, twilioMessageKey, client, device),
        sendTeamsReminder(session, teamsMessageKey, client, device),
      )
    } else if (session.sessionRespondedVia === SERVICES.TWILIO) {
      messagingPromises.push(sendTwilioReminder(session, twilioMessageKey, client, device))
    } else if (session.sessionRespondedVia === SERVICES.TEAMS) {
      messagingPromises.push(sendTeamsReminder(session, teamsMessageKey, client, device))
    }

    if (messagingPromises.length > 0) {
      await Promise.allSettled(messagingPromises)
      helpers.log(`Processed stillness reminder ${reminderNumber} actions for session ${sessionId}`)
    }
  } catch (error) {
    helpers.logError(`Error in handleStillnessReminder ${reminderNumber} for session ${sessionId}: ${error.message}`)
  }
}

async function sendTwilioFallback(session, twilioMessageKey, client, device) {
  if (!session || !session.sessionId || !twilioMessageKey || !client || !client.responderPhoneNumbers || !device) {
    throw new Error(`sendTwilioFallback: Missing required parameters`)
  }

  try {
    const textMessage = helpers.translateMessageKeyToMessage(twilioMessageKey, client, device)
    const targetNumbers = client.fallbackPhoneNumbers

    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, targetNumbers, textMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.STILLNESS_ALERT, twilioMessageKey, targetNumbers)
  } catch (error) {
    throw new Error(`sendTwilioFallback: ${error.message}`)
  }
}

async function handleStillnessFallback(session, client, device, sessionId) {
  if (!client.fallbackPhoneNumbers || client.fallbackPhoneNumbers.length === 0) {
    helpers.log(`No fallback numbers for client ${client.clientId}, skipping fallback for session ${session.sessionId}`)
    return
  }

  try {
    const twilioMessageKey = 'stillnessAlertFallback'
    await sendTwilioFallback(session, twilioMessageKey, client, device)
  } catch (error) {
    helpers.logError(`Error in handleStillnessFallback for session ${sessionId}: ${error.message}`)
  }
}
async function scheduleStillnessAlertReminders(client, device, sessionId) {
  const stillnessReminderTimeout = stillnessReminderinSeconds * 1000
  const startTime = Date.now()

  helpers.log(`Starting to schedule stillness reminders for session ${sessionId}. Reminder interval: ${stillnessReminderinSeconds} seconds`)

  function scheduleAt(targetTime, fn, reminderNumber) {
    const delay = targetTime - Date.now()
    const scheduledTime = new Date(targetTime).toISOString()
    const delayMinutes = Math.round((delay / 1000 / 60) * 10) / 10

    helpers.log(`Reminder #${reminderNumber} scheduled for ${scheduledTime} (in ${delayMinutes} minutes) for session ${sessionId}`)

    return new Promise(resolve =>
      setTimeout(async () => {
        helpers.log(`Executing reminder #${reminderNumber} for session ${sessionId}`)
        await fn()
        resolve()
      }, Math.max(delay, 0)),
    )
  }

  async function sendReminder(reminderNumber) {
    try {
      const currentSession = await db_new.getLatestSessionWithDeviceId(device.deviceId)
      if (currentSession.sessionId !== sessionId) {
        throw new Error(`Current session changed from ${sessionId} to ${currentSession.sessionId}, cancelling reminder`)
      }

      // get latest event based on the session's attending via service if any
      // default to twilio if not teams
      const latestEvent =
        currentSession.sessionRespondedVia === SERVICES.TEAMS
          ? await db_new.getLatestRespondableTeamsEvent(currentSession.sessionId, null)
          : await db_new.getLatestRespondableTwilioEvent(currentSession.sessionId, null)

      // make sure that the latest event is a type of stillness alert
      if (!latestEvent || !latestEvent.eventType || latestEvent.eventType !== EVENT_TYPE.STILLNESS_ALERT) {
        throw new Error(`Latest event is not a type of  stillness alert, cancelling reminders for ${sessionId}`)
      }

      if (currentSession.sessionStatus === SESSION_STATUS.ACTIVE && !currentSession.doorOpened && !currentSession.surveySent) {
        // When sending second reminder, notify fallback (functionality only for twilio)
        if (reminderNumber === 2) {
          await Promise.all([
            handleStillnessReminder(reminderNumber, currentSession, client, device, sessionId),
            handleStillnessFallback(currentSession, client, device, sessionId),
          ])
        } else {
          await handleStillnessReminder(reminderNumber, currentSession, client, device, sessionId)
        }
      } else {
        helpers.log(`Reminder ${reminderNumber} skipped: session invalid or already resolved.`)
      }
    } catch (error) {
      helpers.log(`scheduleStillnessAlertReminders: ${error.message}`)
    }
  }

  // Schedule all reminders at fixed intervals from start
  scheduleAt(startTime + stillnessReminderTimeout, () => sendReminder(1), 1)
  scheduleAt(startTime + 2 * stillnessReminderTimeout, () => sendReminder(2), 2)
  scheduleAt(startTime + 3 * stillnessReminderTimeout, () => sendReminder(3), 3)
}

// ----------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------

async function sendTwilioAlertForSession(session, eventType, eventData, twilioMessageKey, client, device, pgClient) {
  if (!session || !session.sessionId || !twilioMessageKey || !client || !device) {
    throw new Error(`sendTwilioAlert: Missing required parameters (session, key, client, or device)`)
  }

  try {
    const messageData = { occupancyDuration: Math.round(eventData.occupancyDuration || 0) }
    const textMessage = helpers.translateMessageKeyToMessage(twilioMessageKey, client, device, messageData)

    // send message to only attending responder phone number if set
    // otherwise, send the message to all responders
    const targetNumbers = session.attendingResponderNumber ? session.attendingResponderNumber : client.responderPhoneNumbers
    if (!targetNumbers || (Array.isArray(targetNumbers) && targetNumbers.length === 0)) {
      helpers.log(`Skipping Twilio alert ${twilioMessageKey} for session ${session.sessionId}: No target phone numbers found.`)
      return
    }

    // send alert to targetNumbers and log event
    await twilioHelpers.sendMessageToPhoneNumbers(device.deviceTwilioNumber, targetNumbers, textMessage)
    await db_new.createEvent(session.sessionId, eventType, twilioMessageKey, targetNumbers, pgClient)

    helpers.log(`Sent Twilio message ${twilioMessageKey} for existing session ${session.sessionId}`)
  } catch (error) {
    throw new Error(`sendTwilioAlertForExistingSession: ${error.message}`)
  }
}

async function sendTeamsAlertForSession(session, eventType, eventData, teamsMessageKey, client, device, pgClient) {
  if (!session || !session.sessionId || !teamsMessageKey || !client || !device) {
    throw new Error(`sendTeamsAlert: Missing required parameters (session, key, client, or device)`)
  }

  // check if teams is configured
  if (!client.teamsId || !client.teamsAlertChannelId) {
    helpers.log(`Skipping Teams update for session ${session.sessionId}: Teams not configured for client ${client.clientId}`)
    return
  }

  try {
    // create a 'New' card with additional messageData
    const messageData = { occupancyDuration: Math.round(eventData.occupancyDuration || 0) }
    const cardType = 'New'
    const adaptiveCard = teamsHelpers.createAdaptiveCard(teamsMessageKey, cardType, client, device, messageData)
    if (!adaptiveCard) {
      throw new Error(`Failed to create adaptive card for teams event: ${teamsMessageKey}`)
    }

    // send card to teams alert channel
    // Note: when sending a 'New' teams card, it automatically expires the last alert
    const response = await teamsHelpers.sendNewTeamsCard(client.teamsId, client.teamsAlertChannelId, adaptiveCard, session)
    if (!response || !response.messageId) {
      throw new Error(`Failed to send new Teams card or invalid response received for session ${session.sessionId}`)
    }

    // log teams event with its messageId
    await db_new.createTeamsEvent(session.sessionId, eventType, teamsMessageKey, response.messageId, pgClient)
    helpers.log(`Sent Teams alert ${teamsMessageKey} for new session ${session.sessionId}, messageId: ${response.messageId}`)
  } catch (error) {
    throw new Error(`sendTeamsAlertForNewSession: ${error.message}`)
  }
}

async function getMessageKeysForExistingSession(eventType, latestSession, pgClient) {
  try {
    switch (eventType) {
      case EVENT_TYPE.DURATION_ALERT:
        return {
          twilioMessageKey: 'durationAlert',
          teamsMessageKey: 'teamsDurationAlert',
        }
      case EVENT_TYPE.STILLNESS_ALERT:
        return {
          twilioMessageKey: 'stillnessAlert',
          teamsMessageKey: 'teamsStillnessAlert',
        }
      case EVENT_TYPE.DOOR_OPENED: {
        // check the preceding event to determine the type of message to send
        // use any service (twilio, teams)
        const latestEvent = await db_new.getLatestRespondableTwilioEvent(latestSession.sessionId, null, pgClient)
        if (!latestEvent) {
          throw new Error(`No latest event found for session ID: ${latestSession.sessionId}`)
        }

        switch (latestEvent.eventType) {
          case EVENT_TYPE.DURATION_ALERT:
            return {
              twilioMessageKey: 'durationAlertSurveyDoorOpened',
              teamsMessageKey: 'teamsDurationAlertSurveyDoorOpened',
            }
          case EVENT_TYPE.STILLNESS_ALERT:
            return {
              twilioMessageKey: 'stillnessAlertSurveyDoorOpened',
              teamsMessageKey: 'teamsStillnessAlertSurveyDoorOpened',
            }
          case EVENT_TYPE.MSG_SENT: {
            if (latestEvent.eventTypeDetails === 'stillnessAlertFollowup') {
              return {
                twilioMessageKey: 'stillnessAlertSurveyDoorOpened',
                teamsMessageKey: 'teamsStillnessAlertSurveyDoorOpened',
              }
            }
            helpers.log(
              `Received door opened and latest event not a stillness followup: ${latestEvent.eventTypeDetails}, only updating door opened status for sessionId: ${latestSession.sessionId}`,
            )
            return null
          }
          default: {
            helpers.log(
              `Received door opened, error processing event type: ${latestEvent.eventType}, only updating door opened status for sessionId: ${latestSession.sessionId}`,
            )
            return null
          }
        }
      }
      default: {
        throw new Error(`Invalid event type: ${eventType}`)
      }
    }
  } catch (error) {
    throw new Error(`getMessageKeysForExistingSession: ${error.message}`)
  }
}

async function handleExistingSession(client, device, eventType, eventData, latestSession, pgClient) {
  try {
    const messageKeys = await getMessageKeysForExistingSession(eventType, latestSession, pgClient)

    // If messageKey is null, only update door opened status for DOOR_OPENED events and exit
    // For other event types, do nothing and return null
    if (!messageKeys && eventType === EVENT_TYPE.DOOR_OPENED) {
      const updatedSession = await db_new.updateSession(
        latestSession.sessionId,
        latestSession.sessionStatus,
        true,
        latestSession.surveySent,
        pgClient,
      )

      if (!updatedSession) {
        throw new Error(`Failed to update session ${latestSession.sessionId}`)
      }
    } else if (!messageKeys) {
      return null
    }

    const { twilioMessageKey, teamsMessageKey } = messageKeys

    // only send the door opened surveys if survey was NOT sent
    if (latestSession.surveySent && (twilioMessageKey === 'stillnessAlertSurveyDoorOpened' || twilioMessageKey === 'durationAlertSurveyDoorOpened')) {
      throw new Error('Attempting to send door opened survey, but survey was already sent')
    }

    // if the session is in progress, then send the message via the selected service
    // otherwise, send using all methods (twilio, teams)
    if (!latestSession.sessionRespondedVia) {
      await Promise.allSettled([
        sendTwilioAlertForSession(latestSession, eventType, eventData, twilioMessageKey, client, device, pgClient),
        sendTeamsAlertForSession(latestSession, eventType, eventData, teamsMessageKey, client, device, pgClient),
      ])
    } else if (latestSession.sessionRespondedVia === SERVICES.TWILIO) {
      await sendTwilioAlertForSession(latestSession, eventType, eventData, twilioMessageKey, client, device, pgClient)
    } else if (latestSession.sessionRespondedVia === SERVICES.TEAMS) {
      await sendTeamsAlertForSession(latestSession, eventType, eventData, teamsMessageKey, client, device, pgClient)
    }

    // update the session
    let updatedSession = null
    if (eventType === EVENT_TYPE.DOOR_OPENED) {
      const sessionUpdates = {
        doorOpened: true,
        surveySent:
          twilioMessageKey === 'stillnessAlertSurveyDoorOpened' || twilioMessageKey === 'durationAlertSurveyDoorOpened'
            ? true
            : latestSession.surveySent,
      }

      updatedSession = await db_new.updateSession(
        latestSession.sessionId,
        latestSession.sessionStatus,
        sessionUpdates.doorOpened,
        sessionUpdates.surveySent,
        pgClient,
      )

      if (!updatedSession) {
        throw new Error(`Failed to update session ${latestSession.sessionId}`)
      }
    }

    // if we sent a stillness alert was sent, then schedule stillness reminders and fallbacks
    // NOTE: these are scheduled outside this transaction
    if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      scheduleStillnessAlertReminders(client, device, latestSession.sessionId)
    }

    return updatedSession
  } catch (error) {
    throw new Error(`handleExistingSession: Error handling existing session with session ID ${latestSession.sessionId}: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

function getMessageKeysForNewSession(eventType, device) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return {
        twilioMessageKey: 'durationAlert',
        teamsMessageKey: 'teamsDurationAlert',
      }
    case EVENT_TYPE.STILLNESS_ALERT:
      return {
        twilioMessageKey: 'stillnessAlert',
        teamsMessageKey: 'teamsStillnessAlert',
      }
    case EVENT_TYPE.DOOR_OPENED:
      helpers.log(`Received door opened as the first alert ... ignoring alert for deviceId: ${device.deviceId}`)
      return null
    default: {
      throw new Error(`getMessageKeysForNewSession: Invalid event type received as the first alert: ${eventType}`)
    }
  }
}

async function handleNewSession(client, device, eventType, eventData, pgClient) {
  try {
    const messageKeys = getMessageKeysForNewSession(eventType, device)
    if (!messageKeys) {
      helpers.log(`handleNewSession: No initial action determined for eventType ${eventType}.`)
      return null
    }

    const { twilioMessageKey, teamsMessageKey } = messageKeys

    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession) {
      throw new Error(`Failed to create a new session`)
    }

    // send initial alerts
    await Promise.allSettled([
      sendTwilioAlertForSession(newSession, eventType, eventData, twilioMessageKey, client, device, pgClient),
      sendTeamsAlertForSession(newSession, eventType, eventData, teamsMessageKey, client, device, pgClient),
    ])

    // if we sent a stillness alert was sent, then schedule stillness reminders and fallbacks
    // NOTE: these are scheduled outside this transaction
    if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      helpers.log(`Scheduling stillness reminders for new session ${newSession.sessionId}`)
      scheduleStillnessAlertReminders(client, device, newSession.sessionId)
    }

    return newSession
  } catch (error) {
    throw new Error(`handleNewSession: Error handling new session for device ID: ${device.deviceId} - ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

async function processSensorEvent(client, device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = `Error starting transaction - processSensorEvent: deviceId: ${device.deviceId}, eventType: ${eventType}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    if (eventData.numStillnessAlertsSent > 1) {
      throw new Error(`More than one stillness alert received for device: ${device.deviceId}`)
    }

    const latestSession = await db_new.getLatestSessionWithDeviceId(device.deviceId, pgClient)

    let returnedSession = null

    // Create new session if none exists
    if (!latestSession) {
      returnedSession = await handleNewSession(client, device, eventType, eventData, pgClient)
    }
    // If door was opened, create a new session and mark pervious one as stale
    else if (latestSession.sessionStatus === SESSION_STATUS.ACTIVE && latestSession.doorOpened) {
      returnedSession = await handleNewSession(client, device, eventType, eventData, pgClient)
      if (!returnedSession) {
        await db_new.commitTransaction(pgClient)
        return
      }
      helpers.log(`Created new session, marking previous session ${latestSession.sessionId} as stale.`)
      await db_new.updateSession(latestSession.sessionId, SESSION_STATUS.STALE, latestSession.doorOpened, latestSession.surveySent, pgClient)
    }
    // Create new session if previous one was completed
    else if (latestSession.sessionStatus === SESSION_STATUS.COMPLETED && latestSession.doorOpened) {
      helpers.log(`Creating new session after completed session ${latestSession.sessionId}`)
      returnedSession = await handleNewSession(client, device, eventType, eventData, pgClient)
    }
    // Handle event for existing active session
    else {
      returnedSession = await handleExistingSession(client, device, eventType, eventData, latestSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        throw new Error(`Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
      }
    }
    throw new Error(`processSensorEvent: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Events (/api/sensorEvent)

const validateSensorEvent = [
  Validator.body('event')
    .exists()
    .isString()
    .custom(value => {
      const validEvents = ['Duration Alert', 'Stillness Alert', 'Door Opened']
      return validEvents.includes(value)
    }),
  Validator.body('data').exists().isString(),
  Validator.body('coreid').exists().isString(),
  Validator.body('api_key').exists().isString(),
]

function parseSensorEventType(receivedEventType) {
  const eventTypeMapping = {
    'Duration Alert': EVENT_TYPE.DURATION_ALERT,
    'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
    'Door Opened': EVENT_TYPE.DOOR_OPENED,
  }
  const eventType = eventTypeMapping[receivedEventType]
  if (!eventType) throw new Error(`Unknown event type: ${receivedEventType}`)
  return eventType
}

function parseSensorEventData(receivedEventData) {
  const eventData = typeof receivedEventData === 'string' ? JSON.parse(receivedEventData) : receivedEventData
  if (!eventData) throw new Error('Error parsing event data')

  const requiredFields = ['alertSentFromState', 'numDurationAlertsSent', 'numStillnessAlertsSent', 'occupancyDuration']

  for (const field of requiredFields) {
    if (!(field in eventData)) {
      throw new Error(`Missing required field: ${field}`)
    }
  }

  return eventData
}

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      throw new Error(`Bad request: ${validationErrors.array()}`)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body
    if (api_key !== particleWebhookAPIKey) {
      throw new Error('Access not allowed: Invalid API key')
    }

    const eventType = parseSensorEventType(receivedEventType)
    const eventData = parseSensorEventData(receivedEventData)

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      throw new Error(`No device matches the coreID: ${particleDeviceID}`)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (!client) {
      throw new Error(`No client found for device: ${device.deviceId}`)
    }

    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      await processSensorEvent(client, device, eventType, eventData)
    }

    response.status(200).json('OK')
  } catch (error) {
    helpers.logError(`Error on ${request.path}: ${error.message}`)
    // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
    response.status(200).json(error.message)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

module.exports = {
  validateSensorEvent,
  handleSensorEvent,
}
