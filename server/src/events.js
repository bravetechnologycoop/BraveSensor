/*
 * events.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE } = require('./enums/index')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')

// ------------------------------------------------------------------------------------------------

function getEventTypeDetails(eventType) {
  helpers.log(`getEventTypeDetails: eventType = ${eventType}`)
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'DurationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'StillnessAlert'
    default:
      return null
  }
}

async function sendMessageToAllResponders(device, textMessage, sessionId) {
  helpers.log(`sendMessageToAllResponders: device = ${device.deviceId}, textMessage = ${textMessage}, sessionId = ${sessionId}`)
  try {
    const client = await db_new.getClientWithClientId(device.clientId)
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber

    // translate the message to client's language (default to 'en')
    const clientLanguage = client.language || 'en'
    const translatedMessage = i18next.t(textMessage, { lng: clientLanguage })

    if (deviceTwilioNumber && responderPhoneNumbers.length > 0) {
      const sendPromises = responderPhoneNumbers.map(toPhoneNumber =>
        twilioHelpers.sendTwilioMessage(toPhoneNumber, deviceTwilioNumber, translatedMessage),
      )

      const responses = await Promise.all(sendPromises)

      if (!responses || responses.every(response => !response)) {
        helpers.logError(`sendMessageToAllResponders: Failed to send message for session ${sessionId}: ${translatedMessage}`)
      }
    } else {
      helpers.logError('sendMessageToAllResponders: Missing Twilio number or responder phone numbers')
    }
  } catch (error) {
    helpers.logError(`sendMessageToAllResponders: Error sending message: ${error}`)
  }
}

async function handleNewSession(device, eventType, eventData, pgClient) {
  helpers.log(`handleNewSession: device = ${device.deviceId}, eventType = ${eventType}`)
  try {
    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)

    const eventTypeDetails = getEventTypeDetails(eventType)
    if (!eventTypeDetails) {
      throw new Error(`Invalid event type received: ${eventType}`)
    }

    // log the event
    await db_new.createEvent(newSession.sessionId, eventType, eventTypeDetails, pgClient)

    // construct the initial text message
    let textMessage
    if (eventType === EVENT_TYPE.DURATION_ALERT) {
      textMessage = `${device.displayName} has been occupied for ${eventData.occupancyDuration} minutes`
    } else if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      textMessage = `${device.displayName} needs a SAFETY CHECK. On your way? Reply with anything`
    } else {
      helpers.logError('Invalid event type received as the first alert')
    }

    // send message to all responders
    await sendMessageToAllResponders(device, textMessage, newSession.sessionId)
  } catch (error) {
    helpers.logError(`handleNewSession: Error creating new session or event: ${error}`)
    await db_new.rollbackTransaction(pgClient)
  }
}

async function handleExistingSession(currentSession, eventType, pgClient) {
  helpers.log(`handleExistingSession: sessionId = ${currentSession.sessionId}, eventType = ${eventType}`)
  try {
    if (eventType === EVENT_TYPE.DURATION_ALERT) {
      helpers.log('Received duration alert for already existing active session')
    } else if (eventType === EVENT_TYPE.STILLNESS_ALERT) {
      helpers.log('Received stillness alert for already existing active session')
    } else if (eventType === EVENT_TYPE.DOOR_OPENED) {
      helpers.log('Received door opened for already existing active session')
    }
  } catch (error) {
    helpers.logError(`handleExistingSession: Error updating session or logging event: ${error}`)
    await db_new.rollbackTransaction(pgClient)
  }
}

async function processSensorEvent(device, eventType, eventData) {
  helpers.log(`processSensorEvent: device = ${device.deviceId}, eventType = ${eventType}`)
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      helpers.logError(`processEvent: Error starting transaction`)
      return
    }

    const currentSession = await db_new.getCurrentSessionWithDeviceId(device.deviceId, pgClient)

    if (!currentSession) {
      await handleNewSession(device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(currentSession, eventType, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    try {
      helpers.logError(`processEvent: Rolled back transaction because of error: ${error}`)
      if (pgClient) {
        await db_new.rollbackTransaction(pgClient)
      }
    } catch (rollbackError) {
      helpers.logError(`processEvent: Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
    }
  }
}

// ------------------------------------------------------------------------------------------------

function respondWithError(response, errorMessage, path) {
  helpers.logError(`Error on ${path}: ${errorMessage}`)
  // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
  response.status(200).json(errorMessage)
}

function getEventType(receivedEventType, response, path) {
  helpers.log(`getEventType: receivedEventType = ${receivedEventType}`)
  // Map event type from string to enum
  const eventTypeMapping = {
    'Duration Alert': EVENT_TYPE.DURATION_ALERT,
    'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
    'Door Opened': EVENT_TYPE.DOOR_OPENED,
  }

  const eventType = eventTypeMapping[receivedEventType]
  if (!eventType) {
    respondWithError(response, `Unknown event type: ${receivedEventType}`, path)
  }

  return eventType
}

function parseEventData(receivedEventData, response, path) {
  helpers.log(`parseEventData: receivedEventData = ${receivedEventData}`)
  if (typeof receivedEventData !== 'string') return receivedEventData
  try {
    // Parse event data from string to JSON
    return JSON.parse(receivedEventData)
  } catch (error) {
    respondWithError(response, `Error parsing eventData: ${error.toString()}`, path)
    return null
  }
}

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

async function handleSensorEvent(request, response) {
  helpers.log(`handleSensorEvent: request.body = ${JSON.stringify(request.body)}`)
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      return respondWithError(response, `Bad request: ${validationErrors.array()}`, request.path)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body

    if (api_key !== particleWebhookAPIKey) {
      return respondWithError(response, `Access not allowed`, request.path)
    }

    const eventType = getEventType(receivedEventType, response, request.path)
    if (!eventType) return
    const eventData = parseEventData(receivedEventData, response, request.path)
    if (!eventData) return

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      return respondWithError(response, `No device matches the coreID ${particleDeviceID}`, request.path)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      // process the sensor event if alerts are enabled
      await processSensorEvent(device, eventType, eventData)
    }

    response.status(200).json('OK')
  } catch (error) {
    respondWithError(response, `Error processing request: ${error.toString()}`, request.path)
  }
}

// ------------------------------------------------------------------------------------------------

module.exports = {
  validateSensorEvent,
  handleSensorEvent,
}
