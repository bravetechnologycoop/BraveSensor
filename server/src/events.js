/*
 * events.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')
const twilio = require('twilio')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE, SESSION_STATUS } = require('./enums/index')
const { resumeStateMachineMonitoring } = require('./particle')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')
const STILLNESS_ALERT_SURVEY_FOLLOWUP = helpers.getEnvVar('STILLNESS_ALERT_SURVEY_FOLLOWUP')
const TWILIO_TOKEN = helpers.getEnvVar('TWILIO_TOKEN')

// ----------------------------------------------------------------------------------------------------------------------------
// Incoming Message Handlers

async function handleNonAttendingConfirmation(session, responderPhoneNumber, deviceTwilioNumber, client, clientLanguage, pgClient) {
  try {
    const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
    const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })

    const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)

    const nonAttendingConfirmationSent = await db_new.checkEventExists(
      session.sessionId,
      EVENT_TYPE.MSG_SENT,
      nonAttendingResponseMessageKey,
      pgClient,
    )
    if (!nonAttendingConfirmationSent) {
      for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
        await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, phoneNumber, nonAttendingResponseMessage)
        await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
      }
    }
  } catch (error) {
    throw new Error(`handleNonAttendingConfirmation: Error sending non-attending confirmation: ${error.message}`)
  }
}

async function handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient) {
  try {
    const responseMessageKey = 'invalidResponseTryAgain'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

    await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
  } catch (error) {
    throw new Error(`handleInvalidResponse: Error sending invalid response: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

async function handleDurationAlertSurveyPromptDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategoriesForMessage,
  pgClient,
) {
  try {
    if (message === '0') {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyPromptDoorOpened', pgClient)

      // construct the response message
      const responseMessageKey = 'durationAlertSurveyDoorOpened'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage, surveyCategoriesForMessage })

      // check that the door must be opened
      if (!session.doorOpened) {
        throw new Error(`handleDurationAlertSurveyDoorOpened: Door is not opened for session ID: ${session.sessionId}`)
      }

      // update the session
      await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    throw new Error(`handleDurationAlertSurveyPromptDoorOpened: Error handling message: ${error.message}`)
  }
}

async function handleDurationAlertSurveyDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategories,
  pgClient,
) {
  try {
    const messageIndex = parseInt(message, 10)
    if (messageIndex >= 0 && messageIndex <= surveyCategories.length) {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyDoorOpened', pgClient)

      // construct the response message
      let responseMessageKey
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Occupant Okay':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Other':
          responseMessageKey = 'durationAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      // check that the door must be opened
      if (!session.doorOpened) {
        throw new Error(`handleDurationAlertSurveyDoorOpened: Door is not opened for session ID: ${session.sessionId}`)
      }

      // update the session
      await db_new.updateSessionSelectedSurveyCategory(session.sessionId, selectedCategory, pgClient)
      if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
      } else {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
      }

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    throw new Error(`handleDurationAlertSurveyDoorOpened: Error handling message: ${error}`)
  }
}

async function handleDurationAlertSurveyOtherFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    // log the message received with message details
    const eventTypeDetails = `durationAlertSurveyOtherFollowup: ${message}`
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, eventTypeDetails, pgClient)

    // construct the response message
    const responseMessageKey = 'thankYou'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

    // check that the door must be opened
    if (!session.doorOpened) {
      throw new Error(`handleDurationAlertSurveyOtherFollowup: Door is not opened for session ID: ${session.sessionId}`)
    }

    // update the session - End
    await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)

    // send message to attending responder and log the message sent
    await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
  } catch (error) {
    throw new Error(`handleDurationAlertSurveyOtherFollowup: Error handling message: ${error}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

// Trigger function
async function handleStillnessAlertFollowupTrigger(deviceId, responderPhoneNumber, deviceTwilioNumber, clientLanguage, surveyCategoriesForMessage) {
  let pgClient
  try {
    // start a new transaction
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      helpers.logError(`handleStillnessAlertFollowupTrigger: Failed to start transaction for deviceId: ${deviceId}`)
      return
    }

    try {
      // Use deviceId to get the latest session info
      const session = await db_new.getLatestActiveSessionWithDeviceId(deviceId, pgClient)
      if (!session) {
        helpers.logError(`handleStillnessAlertFollowupTrigger: No active session found for deviceId: ${deviceId}`)
        await db_new.rollbackTransaction(pgClient)
        return
      }

      // make sure the session survey is not sent due to door open while waiting for trigger
      if (!session.surveySent && !session.doorOpened) {
        // construct the response message
        const responseMessageKey = 'stillnessAlertSurvey'
        const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage, surveyCategoriesForMessage })

        // update the session
        // the door must have been closed when this survey was sent
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, false, true, pgClient)

        // send message to attending responder and log the message sent
        await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
        await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
      }

      // commit the transaction
      await db_new.commitTransaction(pgClient)
    } catch (error) {
      helpers.logError(`handleStillnessAlertFollowupTrigger: Error handling message: ${error}`)
      await db_new.rollbackTransaction(pgClient)
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlertFollowupTrigger: Error starting transaction: ${error}`)
  }
}

async function handleStillnessAlert(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategoriesForMessage,
  pgClient,
) {
  try {
    if (message === '5' || message.toLowerCase() === 'k') {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlert', pgClient)

      // construct the response message
      const responseMessageKey = 'stillnessAlertFollowup'
      const responseMessage = i18next.t(responseMessageKey, {
        lng: clientLanguage,
        stillnessAlertFollowupTimer: STILLNESS_ALERT_SURVEY_FOLLOWUP,
      })

      // update the session
      // the door can be opened or closed when a response to a stillnessAlert is received
      if (session.doorOpened) {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, false, pgClient)
      } else {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, false, false, pgClient)
      }

      // Trigger the function STILLNESS_ALERT_SURVEY_FOLLOWUP minutes later to send survey
      setTimeout(() => {
        handleStillnessAlertFollowupTrigger(session.deviceId, responderPhoneNumber, deviceTwilioNumber, clientLanguage, surveyCategoriesForMessage)
      }, STILLNESS_ALERT_SURVEY_FOLLOWUP * 60 * 1000)

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    throw new Error(`handleStillnessAlert: Error handling message: ${error}`)
  }
}

async function handleStillnessAlertSurvey(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient) {
  try {
    const messageIndex = parseInt(message, 10)
    if (messageIndex >= 0 || messageIndex <= surveyCategories.length) {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurvey', pgClient)

      // construct the response message
      let responseMessageKey
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Occupant Okay': {
          if (!session.doorOpened) {
            responseMessageKey = 'stillnessAlertSurveyOccupantOkayFollowup'
          } else {
            responseMessageKey = 'thankYou'
          }
          break
        }
        case 'Other':
          responseMessageKey = 'stillnessAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      // update the session
      // the door could have been opened after the survey was sent
      if (session.doorOpened && (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo')) {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
      } else if (!session.doorOpened && (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo')) {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, false, true, pgClient)
      } else if (session.doorOpened) {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
      } else {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, false, true, pgClient)
      }

      await db_new.updateSessionSelectedSurveyCategory(session.sessionId, selectedCategory, pgClient)

      // continue monitoring and resume all sensor alerts
      // in firmware, the variables are reset for both state 2 and 3 including timers and alert counts
      // this session will remain active and all incoming alerts will be treated as if it was a existing session
      if (!session.doorOpened && responseMessageKey === 'stillnessAlertSurveyOccupantOkayFollowup') {
        await resumeStateMachineMonitoring(session.deviceId)
      }

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    throw new Error(`handleStillnessAlertSurvey: Error handling message: ${error}`)
  }
}

async function handleStillnessAlertSurveyDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategories,
  pgClient,
) {
  try {
    const messageIndex = parseInt(message, 10)
    const surveySent = session.surveySent
    if (messageIndex >= 0 || (messageIndex <= surveyCategories.length && !surveySent)) {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurveyDoorOpened', pgClient)

      // construct the response message
      let responseMessageKey
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Occupant Okay':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Other':
          responseMessageKey = 'stillnessAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      // check that the must be opened
      if (!session.doorOpened) {
        throw new Error(`handleDurationAlertSurveyOtherFollowup: Door is not opened for session ID: ${session.sessionId}`)
      }

      // update the session
      await db_new.updateSessionSelectedSurveyCategory(session.sessionId, selectedCategory, pgClient)
      if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
      } else {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
      }

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
      return
    }
  } catch (error) {
    throw new Error(`handleStillnessAlertSurveyDoorOpened: Error handling message: ${error}`)
  }
}

async function handleStillnessAlertSurveyOccupantOkayFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    if (message === '1') {
      // log the message received
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurveyOccupantOkayFollowup', pgClient)

      // construct the response message
      const responseMessageKey = 'stillnessAlertSurveyOccupantOkayEnd'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      // check that the door must NOT be opened
      if (session.doorOpened) {
        throw new Error(`handleDurationAlertSurveyOtherFollowup: Door is not opened for session ID: ${session.sessionId}`)
      }

      // update the session - End
      await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)

      // send message to attending responder and log the message sent
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
    } else {
      await handleInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    throw new Error(`handleStillnessAlertSurveyOccupantOkayFollowup: Error handling message: ${error}`)
  }
}

async function handleStillnessAlertSurveyOtherFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    // log the message received with message details
    const eventTypeDetails = `stillnessAlertSurveyOtherFollowup: ${message}`
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, eventTypeDetails, pgClient)

    // construct the response message
    const responseMessageKey = 'thankYou'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

    // update the session
    if (session.doorOpened) {
      await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
    } else {
      await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, false, true, pgClient)
    }

    // send message to attending responder and log the message sent
    await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumber, responseMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
  } catch (error) {
    helpers.logError(`handleStillnessAlertSurveyOtherFollowup: Error handling message: ${error}`)
    throw error
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Incoming Twilio Message Events (/alert/sms)

async function handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId, pgClient)
  const clientLanguage = client.language || 'en'
  const surveyCategories = client.surveyCategories
  const surveyCategoriesForMessage = surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')

  try {
    // set the attending responder number if not already set (first event)
    if (!latestSession.attendingResponderNumber) {
      await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
    }

    // set the response time if not already set (first event)
    if (!latestSession.responseTime) {
      await db_new.updateSessionResponseTime(latestSession.sessionId, pgClient)
    }

    // handle each respondable event
    const latestRespondableEventDetails = latestRespondableEvent.eventTypeDetails
    switch (latestRespondableEventDetails) {
      case 'durationAlertSurveyPromptDoorOpened':
        await handleDurationAlertSurveyPromptDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategoriesForMessage,
          pgClient,
        )
        break
      case 'durationAlertSurveyDoorOpened':
        await handleDurationAlertSurveyDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategories,
          pgClient,
        )
        break
      case 'durationAlertSurveyOtherFollowup':
        await handleDurationAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient)
        break
      case 'stillnessAlert':
        await handleStillnessAlert(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategoriesForMessage,
          pgClient,
        )
        break
      case 'stillnessAlertSurvey':
        await handleStillnessAlertSurvey(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient)
        break
      case 'stillnessAlertSurveyDoorOpened':
        await handleStillnessAlertSurveyDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategories,
          pgClient,
        )
        break
      case 'stillnessAlertSurveyOccupantOkayFollowup':
        await handleStillnessAlertSurveyOccupantOkayFollowup(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          pgClient,
        )
        break
      case 'stillnessAlertSurveyOtherFollowup':
        await handleStillnessAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient)
        break
      default: {
        const errorMessage = `handleIncomingMessage: Unhandled event type: ${latestRespondableEventDetails}`
        helpers.logError(errorMessage)
        throw new Error(errorMessage)
      }
    }

    // send message to non-attending responders if haven't already
    await handleNonAttendingConfirmation(latestSession, responderPhoneNumber, deviceTwilioNumber, client, clientLanguage, pgClient)
  } catch (error) {
    const errorMessage = `handleIncomingMessage: ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

function validateTwilioRequest(request, response, next) {
  if (twilio.validateExpressRequest(request, TWILIO_TOKEN)) {
    next()
  } else {
    const errorMessage = `Bad request to ${request.path}: Sender ${request.body.From} is not Twilio`
    helpers.logError(errorMessage)
    response.status(401).send(errorMessage)
  }
}

async function handleTwilioRequest(request, response) {
  let pgClient

  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      const errorMessage = `Error on ${request.path}: Bad request: ${validationErrors.array()}`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const requiredBodyParams = ['Body', 'From', 'To']
    if (!helpers.isValidRequest(request, requiredBodyParams)) {
      const errorMessage = `Error on ${request.path}: Bad request: Body, From, or To fields are missing`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const responderPhoneNumber = request.body.From
    const deviceTwilioNumber = request.body.To
    const message = request.body.Body

    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = `Error on ${request.path}: Failed to start database transaction`
      helpers.logError(errorMessage)
      response.status(500).send(errorMessage)
      return
    }

    try {
      // Get the latest session for the device
      const latestSession = await db_new.getLatestSessionWithDeviceTwilioNumber(deviceTwilioNumber, pgClient)
      if (!latestSession) {
        const errorMessage = `Error on ${request.path}: No session found for device: ${deviceTwilioNumber}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      // Get the latest respondable event for the session
      // Respondable events are the events that the server expects a response too
      // These are certain events identified by their event details and are handled in handleIncomingMessage
      const latestRespondableEvent = await db_new.getLatestRespondableEvent(latestSession.sessionId, pgClient)
      if (!latestRespondableEvent) {
        const errorMessage = `Error on ${request.path}: No event found for session: ${latestSession.sessionId}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      await handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient)

      await db_new.commitTransaction(pgClient)
      response.status(200).send()
    } catch (error) {
      const errorMessage = `Error on ${request.path}: handleTwilioRequest: Rolled back transaction because of error: ${error}`
      helpers.logError(errorMessage)
      await db_new.rollbackTransaction(pgClient)
      response.status(500).send(errorMessage)
    }
  } catch (error) {
    const errorMessage = `Error on ${request.path}: ${error.toString()}`
    helpers.logError(errorMessage)
    response.status(500).send(errorMessage)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Event Handlers

async function selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient) {
  if (currentSession.doorOpened) return null

  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'

    case EVENT_TYPE.STILLNESS_ALERT:
      if (eventData.numStillnessAlertsSent >= 1 && eventData.numStillnessAlertsSent <= 3) {
        return 'stillnessAlert'
      }
      if (eventData.numStillnessAlertsSent === 4) {
        return 'stillnessAlertFallback'
      }
      break

    case EVENT_TYPE.DOOR_OPENED: {
      if (currentSession.surveySent && currentSession.selectedSurveyCategory === 'Occupant Okay') {
        return 'notifyDoorOpened'
      }

      const latestAlertEvent = await db_new.getLatestAlertEvent(currentSession.sessionId, pgClient)
      if (!latestAlertEvent) {
        throw new Error(`selectMessageKeyForExistingSession: No latest alert event found for session ID: ${currentSession.sessionId}`)
      }

      switch (latestAlertEvent.eventType) {
        case EVENT_TYPE.DURATION_ALERT:
          return 'durationAlertSurveyPromptDoorOpened'
        case EVENT_TYPE.STILLNESS_ALERT:
          return 'stillnessAlertSurveyDoorOpened'
        default: {
          throw new Error(
            `selectMessageKeyForExistingSession: Invalid latest event type: ${latestAlertEvent.eventType} for session ID: ${currentSession.sessionId}`,
          )
        }
      }
    }
    default: {
      throw new Error(`selectMessageKeyForExistingSession: Invalid event type: ${eventType} for session ID: ${currentSession.sessionId}`)
    }
  }
}

async function handleExistingSession(device, eventType, eventData, currentSession, pgClient) {
  try {
    // find the message key
    const messageKey = await selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient)
    if (!messageKey) {
      throw new Error(
        `handleExistingSession: Ignoring Alert: No valid message key found for event type: ${eventType} and session ID: ${currentSession.sessionId}`,
      )
    }

    // construct the translated text message using message key
    const client = await db_new.getClientWithClientId(device.clientId, pgClient)
    const clientLanguage = client.language || 'en'
    const surveyCategoriesForMessage = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceDisplayName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
      surveyCategoriesForMessage,
    })

    // update the session
    // if survey was already sent
    if (currentSession.surveySent && !currentSession.doorOpened) {
      // selected category was 'Occupant Okay'
      if (currentSession.selectedSurveyCategory === 'Occupant Okay') {
        if (eventType === EVENT_TYPE.DURATION_ALERT || eventType === EVENT_TYPE.STILLNESS_ALERT) {
          await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.ACTIVE, false, true, pgClient)
        } else if (eventType === EVENT_TYPE.DOOR_OPENED && messageKey === 'notifyDoorOpened') {
          await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
        }
        // some category was selected
      } else if (currentSession.selectedSurveyCategory !== null) {
        if (eventType === EVENT_TYPE.DOOR_OPENED) {
          await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
          return // end here
        }
        // no category was selected
      } else if (currentSession.selectedSurveyCategory === null) {
        if (eventType === EVENT_TYPE.DOOR_OPENED) {
          await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
          return // end here
        }
        throw new Error('handleExistingSession: Received alert when no survey category was selected. Ignoring alert.')
      }
    }
    // the survey has not been sent
    else if (eventType === EVENT_TYPE.DURATION_ALERT || eventType === EVENT_TYPE.STILLNESS_ALERT) {
      await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.ACTIVE, false, false, pgClient)
    } else if (eventType === EVENT_TYPE.DOOR_OPENED) {
      if (messageKey === 'durationAlertSurveyPromptDoorOpened') {
        await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.ACTIVE, true, false, pgClient)
      } else if (messageKey === 'stillnessAlertSurveyDoorOpened') {
        await db_new.updateSession(currentSession.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
      }
    }

    // send message(s) to respective responders and log the event
    const fallbackPhoneNumbers = client.fallbackPhoneNumbers
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    if (
      messageKey === 'stillnessAlertFallback' &&
      eventData.numStillnessAlertsSent === 4 &&
      fallbackPhoneNumbers &&
      fallbackPhoneNumbers.length > 0
    ) {
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, fallbackPhoneNumbers, textMessage)
      await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
    } else if (
      messageKey === 'notifyDoorOpened' &&
      currentSession.attendingResponderNumber &&
      currentSession.surveySent &&
      currentSession.selectedSurveyCategory === 'Occupant Okay'
    ) {
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, currentSession.attendingResponderNumber, textMessage)
      await db_new.createEvent(currentSession.sessionId, EVENT_TYPE.MSG_SENT, messageKey, pgClient)
    } else {
      await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumbers, textMessage)
      await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
    }
  } catch (error) {
    throw new Error(`handleExistingSession: Error handling existing session with session ID: ${currentSession.sessionId} - ${error.message}`)
  }
}

function selectMessageKeyForNewSession(eventType) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'stillnessAlert'
    default: {
      throw new Error(`selectMessageKeyForNewSession: Invalid event type received as the first alert: ${eventType}`)
    }
  }
}

async function handleNewSession(device, eventType, eventData, pgClient) {
  try {
    // find the message key
    const messageKey = selectMessageKeyForNewSession(eventType)

    // construct the translated text message using message key
    const client = await db_new.getClientWithClientId(device.clientId, pgClient)
    const clientLanguage = client.language || 'en'
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceDisplayName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
    })

    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession || !newSession.sessionId) {
      throw new Error(`handleNewSession: Failed to create a new session for device ID: ${device.deviceId}`)
    }

    // log the event with message key as details
    await db_new.createEvent(newSession.sessionId, eventType, messageKey, pgClient)

    // send message to all responders
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    await twilioHelpers.sendMessageToPhoneNumbers(deviceTwilioNumber, responderPhoneNumbers, textMessage)
  } catch (error) {
    throw new Error(`handleNewSession: Error handling new session for device ID: ${device.deviceId} - ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Events (/api/sensorEvent)

async function processSensorEvent(device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      throw new Error('processSensorEvent: Error starting transaction')
    }

    // A session is finished only if its session_status is COMPLETED and door_opened is true.
    // Ever other session is considered as an "active" session and should be selected here.
    // Those are (status, doorOpened) --> (ACTIVE, true), (ACTIVE, false), (COMPLETED, false)
    const currentSession = await db_new.getLatestActiveSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) {
      await handleNewSession(device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(device, eventType, eventData, currentSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        throw new Error(`processSensorEvent: Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
      }
    }
    throw new Error(`processSensorEvent: Rolled back transaction because of error: ${error.message}`)
  }
}

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

function respondWithError(response, path, errorMessage) {
  helpers.logError(`Error on ${path}: ${errorMessage}`)
  // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
  response.status(200).json(errorMessage)
}

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      return respondWithError(response, request.path, `Bad request: ${validationErrors.array()}`)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body

    if (api_key !== particleWebhookAPIKey) {
      return respondWithError(response, request.path, 'Access not allowed')
    }

    // convert string to defined enum using map
    const eventTypeMapping = {
      'Duration Alert': EVENT_TYPE.DURATION_ALERT,
      'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
      'Door Opened': EVENT_TYPE.DOOR_OPENED,
    }

    const eventType = eventTypeMapping[receivedEventType]
    if (!eventType) {
      return respondWithError(response, request.path, `Unknown event type: ${receivedEventType}`)
    }

    // convert json string to object
    let eventData
    if (typeof receivedEventData !== 'string') {
      eventData = receivedEventData
    } else {
      try {
        eventData = JSON.parse(receivedEventData)
      } catch (error) {
        return respondWithError(response, request.path, `Error parsing eventData: ${error.toString()}`)
      }
    }

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      return respondWithError(response, request.path, `No device matches the coreID ${particleDeviceID}`)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      await processSensorEvent(device, eventType, eventData)
    }

    response.status(200).json('OK')
  } catch (error) {
    respondWithError(response, request.path, `Error processing request: ${error.message}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

module.exports = {
  validateTwilioRequest,
  handleTwilioRequest,
  validateSensorEvent,
  handleSensorEvent,
}
