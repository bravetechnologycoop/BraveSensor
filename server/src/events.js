/*
 * events.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE, SESSION_STATUS } = require('./enums/index')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')

// ------------------------------------------------------------------------------------------------

async function sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage) {
  if (!deviceTwilioNumber || !Array.isArray(responderPhoneNumbers) || responderPhoneNumbers.length === 0) {
    const errorMessage = 'sendMessageToAllResponders: Missing device twilio number or responder phone numbers'
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }

  try {
    const sendPromises = responderPhoneNumbers.map(toPhoneNumber => twilioHelpers.sendTwilioMessage(toPhoneNumber, deviceTwilioNumber, textMessage))

    const responses = await Promise.all(sendPromises)

    const failedResponses = responses.filter(response => !response)
    if (failedResponses.length > 0) {
      const errorMessage = `sendMessageToAllResponders: Failed to send ${failedResponses.length} messages out of ${responderPhoneNumbers.length}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    return responses
  } catch (error) {
    helpers.logError(`sendMessageToAllResponders: Error sending message: ${error}`)
    throw error
  }
}

async function updateSessionBasedOnEventType(eventType, messageKey, sessionId) {
  if (eventType === EVENT_TYPE.DURATION_ALERT || eventType === EVENT_TYPE.STILLNESS_ALERT) {
    await db_new.updateSession(sessionId, SESSION_STATUS.ACTIVE, false)
  } else if (eventType === EVENT_TYPE.DOOR_OPENED) {
    const surveySent = !!(messageKey === 'stillnessAlertSurveyDoorOpened' || messageKey === 'durationAlertDoorOpened')
    await db_new.updateSession(sessionId, SESSION_STATUS.COMPLETED, surveySent)
  }
}

async function selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      if (eventData.numStillnessAlertsSent >= 1 && eventData.numStillnessAlertsSent <= 3) {
        return 'stillnessAlert'
      }
      if (eventData.numStillnessAlertsSent === 4) {
        return 'call'
      }
      helpers.log(`Too many stillness alerts sent: ${eventData.numStillnessAlertsSent}`)
      throw new Error('Too many stillness alerts')

    case EVENT_TYPE.DOOR_OPENED: {
      const latestAlertEvent = await db_new.getLatestAlertEvent(currentSession.sessionId, pgClient)
      if (!latestAlertEvent) {
        helpers.log(`No latest event found for session ID: ${currentSession.sessionId}`)
        throw new Error('No latest event found')
      }

      switch (latestAlertEvent.eventType) {
        case EVENT_TYPE.DURATION_ALERT:
          return 'durationAlertDoorOpened'
        case EVENT_TYPE.STILLNESS_ALERT:
          return 'stillnessAlertSurveyDoorOpened'
        default:
          helpers.log(`Invalid latest event type for session ID: ${currentSession.sessionId}`)
          throw new Error('Invalid latest event type')
      }
    }
    default:
      helpers.logError('Invalid event type')
      throw new Error('Invalid event type')
  }
}

async function handleExistingSession(device, eventType, eventData, currentSession, pgClient) {
  try {
    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const surveyCategories = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
      surveyCategories,
    })

    helpers.log(textMessage)

    // send message to all responders
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)

    await updateSessionBasedOnEventType(eventType, messageKey, currentSession.sessionId)

    // log the event
    await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    helpers.logError(`handleExistingSession: Error handling existing session: ${error}`)
    throw error
  }
}

async function selectMessageKeyForNewSession(eventType) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'stillnessAlert'
    default:
      helpers.logError('Invalid event type received as the first alert')
      throw new Error('Invalid event type')
  }
}

async function handleNewSession(device, eventType, eventData, pgClient) {
  try {
    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession || !newSession.sessionId) {
      throw new Error('Failed to create a new session')
    }

    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForNewSession(eventType)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
    })

    helpers.log(textMessage)

    // send message to all responders
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)

    // log the event
    await db_new.createEvent(newSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    helpers.logError(`handleNewSession: Error handling new session: ${error}`)
    throw error
  }
}

async function processSensorEvent(device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      helpers.logError(`processEvent: Error starting transaction`)
      return
    }

    const currentSession = await db_new.getCurrentSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) {
      await handleNewSession(device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(device, eventType, eventData, currentSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    try {
      helpers.logError(`processEvent: Rolled back transaction because of error: ${error}`)
      if (pgClient) {
        await db_new.rollbackTransaction(pgClient)
      }
    } catch (rollbackError) {
      helpers.logError(`processEvent: Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`)
    }
  }
}

// ------------------------------------------------------------------------------------------------

function respondWithError(response, errorMessage, path) {
  helpers.logError(`Error on ${path}: ${errorMessage}`)
  // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
  response.status(200).json(errorMessage)
}

function getEventType(receivedEventType, response, path) {
  // Map event type from string to enum
  const eventTypeMapping = {
    'Duration Alert': EVENT_TYPE.DURATION_ALERT,
    'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
    'Door Opened': EVENT_TYPE.DOOR_OPENED,
  }

  const eventType = eventTypeMapping[receivedEventType]
  if (!eventType) {
    respondWithError(response, `Unknown event type: ${receivedEventType}`, path)
  }

  return eventType
}

function parseEventData(receivedEventData, response, path) {
  if (typeof receivedEventData !== 'string') return receivedEventData
  try {
    // Parse event data from string to JSON
    return JSON.parse(receivedEventData)
  } catch (error) {
    respondWithError(response, `Error parsing eventData: ${error.toString()}`, path)
    return null
  }
}

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      return respondWithError(response, `Bad request: ${validationErrors.array()}`, request.path)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body

    if (api_key !== particleWebhookAPIKey) {
      return respondWithError(response, `Access not allowed`, request.path)
    }

    const eventType = getEventType(receivedEventType, response, request.path)
    if (!eventType) return
    const eventData = parseEventData(receivedEventData, response, request.path)
    if (!eventData) return

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      return respondWithError(response, `No device matches the coreID ${particleDeviceID}`, request.path)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      // process the sensor event if alerts are enabled
      await processSensorEvent(device, eventType, eventData)
    }

    response.status(200).json('OK')
  } catch (error) {
    respondWithError(response, `Error processing request: ${error.toString()}`, request.path)
  }
}

// ------------------------------------------------------------------------------------------------

module.exports = {
  validateSensorEvent,
  handleSensorEvent,
}
