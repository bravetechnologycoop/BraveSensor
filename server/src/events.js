/*
 * events.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')
const twilio = require('twilio')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE, SESSION_STATUS } = require('./enums/index')
const resumeStateMachineMonitoring = require('./particle')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')
const STILLNESS_ALERT_SURVEY_FOLLOWUP = helpers.getEnvVar('STILLNESS_ALERT_SURVEY_FOLLOWUP')
const TWILIO_TOKEN = helpers.getEnvVar('TWILIO_TOKEN')

function validateTwilioRequest(request, response, next) {
  if (twilio.validateExpressRequest(request, TWILIO_TOKEN)) {
    next()
  } else {
    const errorMessage = `Bad request to ${request.path}: Sender ${request.body.From} is not Twilio`
    helpers.logError(errorMessage)
    response.status(401).send(errorMessage)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Incoming Message Handlers

async function sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, textMessage) {
  if (!deviceTwilioNumber || !responderPhoneNumber) {
    const errorMessage = 'sendMessageToResponder: Missing device twilio number or responder phone number'
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }

  try {
    const response = await twilioHelpers.sendTwilioMessage(responderPhoneNumber, deviceTwilioNumber, textMessage)

    if (!response) {
      const errorMessage = `sendMessageToResponder: Failed to send message to ${responderPhoneNumber}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    return response
  } catch (error) {
    helpers.logError(`sendMessageToResponder: Error sending message: ${error}`)
    throw error
  }
}

async function sendNonAttendingConfirmation(session, responderPhoneNumber, deviceTwilioNumber, client, clientLanguage, pgClient) {
  const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
  const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })

  const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)

  const nonAttendingConfirmationSent = await db_new.checkEventExists(session.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
  if (!nonAttendingConfirmationSent) {
    for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
      await sendMessageToResponder(phoneNumber, deviceTwilioNumber, nonAttendingResponseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
    }
  }
}

async function sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient) {
  const responseMessageKey = 'invalidResponseTryAgain'
  const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })
  await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
  await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)
}

// ----------------------------------------------------------------------------------------------------------------------------

async function handleDurationAlertSurveyPromptDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  client,
  clientLanguage,
  surveyCategories,
  pgClient,
) {
  try {
    if (message === '0') {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyPromptDoorOpened', pgClient)

      const responseMessageKey = 'durationAlertSurveyDoorOpened'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage, surveyCategories })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyPromptDoorOpened: Error handling message: ${error}`)
    throw error
  }
}

async function handleDurationAlertSurveyDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategories,
  pgClient,
) {
  try {
    const messageIndex = parseInt(message, 10)
    if (messageIndex >= 0 && messageIndex <= surveyCategories.length) {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyDoorOpened', pgClient)

      let responseMessageKey
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Occupant Okay':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Other':
          responseMessageKey = 'durationAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSessionSelectedSurveyCategory(session, selectedCategory, pgClient)

      if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
      }
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
      return
    }
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyDoorOpened: Error handling message: ${error}`)
    throw error
  }
}

async function handleDurationAlertSurveyOtherFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    const eventTypeDetails = `durationAlertSurveyOtherFollowup: ${message}`
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, eventTypeDetails, pgClient)

    const responseMessageKey = 'thankYou'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

    await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

    await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyOtherFollowup: Error handling message: ${error}`)
    throw error
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

// Trigger function
async function handleStillnessAlertFollowupTrigger(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, surveyCategories, pgClient) {
  try {
    const stillnessAlertSurveySent = await db_new.getSessionSurveySent(session.sessionId, pgClient)
    if (!stillnessAlertSurveySent) {
      const responseMessageKey = 'stillnessAlertSurvey'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage, surveyCategories })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, false, true, pgClient)
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlertFollowupTrigger: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlert(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient) {
  try {
    if (message === '5' || message.toLowerCase() === 'k') {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlert', pgClient)

      const responseMessageKey = 'stillnessAlertFollowup'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      // Trigger the function STILLNESS_ALERT_SURVEY_FOLLOWUP minutes later to send survey
      setTimeout(() => {
        handleStillnessAlertFollowupTrigger(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, surveyCategories, pgClient)
      }, STILLNESS_ALERT_SURVEY_FOLLOWUP * 60 * 1000)

      await db_new.updateSession(session.sessionId, SESSION_STATUS.ACTIVE, false, false, pgClient)
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlert: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlertSurvey(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient) {
  try {
    const messageIndex = parseInt(message, 10)
    if (messageIndex >= 0 || messageIndex <= surveyCategories.length) {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurvey', pgClient)

      let responseMessageKey
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Occupant Okay':
          responseMessageKey = 'stillnessAlertSurveyOccupantOkayFollowup'
          break
        case 'Other':
          responseMessageKey = 'stillnessAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSessionSelectedSurveyCategory(session, selectedCategory, pgClient)

      if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, false, true, pgClient)
      }
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
      return
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlertSurvey: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlertSurveyDoorOpened(
  session,
  responderPhoneNumber,
  deviceTwilioNumber,
  message,
  clientLanguage,
  surveyCategories,
  pgClient,
) {
  try {
    const messageIndex = parseInt(message, 10)
    const stillnessAlertSurveySent = await db_new.getSessionSurveySent(session.sessionId, pgClient)
    if (messageIndex >= 0 || (messageIndex <= surveyCategories.length && !stillnessAlertSurveySent)) {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurveyDoorOpened', pgClient)

      let responseMessageKey
      const isDoorOpened = await db_new.getSessionDoorOpened(session.sessionId, pgClient)
      const selectedCategory = surveyCategories[messageIndex]
      switch (selectedCategory) {
        case 'Overdose Event':
        case 'Emergency Event':
        case 'Space Empty':
          responseMessageKey = 'thankYou'
          break
        case 'Occupant Okay':
          if (!isDoorOpened) {
            responseMessageKey = 'stillnessAlertSurveyOccupantOkayFollowup'
          } else {
            responseMessageKey = 'thankYou'
          }
          break
        case 'Other':
          responseMessageKey = 'stillnessAlertSurveyOtherFollowup'
          break
        case 'I would like to contact Brave':
          responseMessageKey = 'braveContactInfo'
          break
        default:
          await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
          return
      }
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSessionSelectedSurveyCategory(session, selectedCategory, pgClient)

      if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
        await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
      }

      // continue monitoring if occupant is okay but door is still closed
      // in sensor, the variables are reset for both state 2 and 3 including timers and alert counts
      // this session will remain active and all incoming alerts will be treated as if it was a existing session
      if (responseMessageKey === 'stillnessAlertSurveyOccupantOkayFollowup' && !isDoorOpened) {
        await resumeStateMachineMonitoring(session.deviceId)
      }
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
      return
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlertSurveyDoorOpened: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlertSurveyOccupantOkayFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    if (message === '1') {
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, 'stillnessAlertSurveyOccupantOkayFollowup', pgClient)

      const responseMessageKey = 'stillnessAlertSurveyOccupantOkayEnd'
      const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
    } else {
      await sendInvalidResponse(session, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    helpers.logError(`handleStillnessAlertSurveyOccupantOkayFollowup: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlertSurveyOtherFollowup(session, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient) {
  try {
    const eventTypeDetails = `stillnessAlertSurveyOtherFollowup: ${message}`
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_RECEIVED, eventTypeDetails, pgClient)

    const responseMessageKey = 'thankYou'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })

    await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
    await db_new.createEvent(session.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

    await db_new.updateSession(session.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
  } catch (error) {
    helpers.logError(`handleStillnessAlertSurveyOtherFollowup: Error handling message: ${error}`)
    throw error
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Incoming Twilio Message Events (/alert/sms)

async function handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId)
  const clientLanguage = client.language || 'en'
  const surveyCategories = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')

  try {
    // set the attending responder number if not already set (first event)
    if (!latestSession.attendingResponderNumber) {
      await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
    }

    // set the response time if not already set (first event)
    if (!latestSession.responseTime) {
      await db_new.updateSessionResponseTime(latestSession.sessionId, pgClient)
    }

    // handle each respondable event
    const latestRespondableEventDetails = latestRespondableEvent.eventTypeDetails
    switch (latestRespondableEventDetails) {
      case 'durationAlertSurveyPromptDoorOpened':
        await handleDurationAlertSurveyPromptDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategories,
          pgClient,
        )
        break
      case 'durationAlertSurveyDoorOpened':
        await handleDurationAlertSurveyDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategories,
          pgClient,
        )
        break
      case 'durationAlertSurveyOtherFollowup':
        await handleDurationAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient)
        break
      case 'stillnessAlert':
        await handleStillnessAlert(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient)
        break
      case 'stillnessAlertSurvey':
        await handleStillnessAlertSurvey(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, surveyCategories, pgClient)
        break
      case 'stillnessAlertSurveyDoorOpened':
        await handleStillnessAlertSurveyDoorOpened(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          surveyCategories,
          pgClient,
        )
        break
      case 'stillnessAlertSurveyOccupantOkayFollowup':
        await handleStillnessAlertSurveyOccupantOkayFollowup(
          latestSession,
          responderPhoneNumber,
          deviceTwilioNumber,
          message,
          clientLanguage,
          pgClient,
        )
        break
      case 'stillnessAlertSurveyOtherFollowup':
        await handleStillnessAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, clientLanguage, pgClient)
        break
      default: {
        const errorMessage = `handleIncomingMessage: Unhandled event type: ${latestRespondableEventDetails}`
        helpers.logError(errorMessage)
        throw new Error(errorMessage)
      }
    }

    // send message to non attending responders if havent already
    await sendNonAttendingConfirmation(latestSession, responderPhoneNumber, deviceTwilioNumber, client, clientLanguage, pgClient)
  } catch (error) {
    const errorMessage = `handleIncomingMessage: : ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function handleTwilioRequest(request, response) {
  let pgClient

  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      const errorMessage = `Error on ${request.path}: Bad request: ${validationErrors.array()}`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const requiredBodyParams = ['Body', 'From', 'To']
    if (!helpers.isValidRequest(request, requiredBodyParams)) {
      const errorMessage = `Error on ${request.path}: Bad request: Body, From, or To fields are missing`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const responderPhoneNumber = request.body.From
    const deviceTwilioNumber = request.body.To
    const message = request.body.Body

    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = `Error on ${request.path}: Failed to start database transaction`
      helpers.logError(errorMessage)
      response.status(500).send(errorMessage)
      return
    }

    try {
      // Get the latest session for the device
      const latestSession = await db_new.getLatestSession(deviceTwilioNumber, pgClient)
      if (!latestSession) {
        const errorMessage = `Error on ${request.path}: No session found for device: ${deviceTwilioNumber}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      // Get the latest respondable event for the session
      // Respondable events are the events that the server expects a response too
      // These are certain events identified by their event details and are handled in handleIncomingMessage
      const latestRespondableEvent = await db_new.getLatestRespondableEvent(latestSession.sessionId, pgClient)
      if (!latestRespondableEvent) {
        const errorMessage = `Error on ${request.path}: No event found for session: ${latestSession.sessionId}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      await handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient)

      await db_new.commitTransaction(pgClient)
      response.status(200).send()
    } catch (error) {
      const errorMessage = `Error on ${request.path}: handleTwilioRequest: Rolled back transaction because of error: ${error}`
      helpers.logError(errorMessage)
      await db_new.rollbackTransaction(pgClient)
      response.status(500).send(errorMessage)
    }
  } catch (error) {
    const errorMessage = `Error on ${request.path}: ${error.toString()}`
    helpers.logError(errorMessage)
    response.status(500).send(errorMessage)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Event Handlers

async function sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage) {
  if (!deviceTwilioNumber || !Array.isArray(responderPhoneNumbers) || responderPhoneNumbers.length === 0) {
    const errorMessage = 'sendMessageToAllResponders: Missing device Twilio number or responder phone numbers'
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }

  try {
    const sendPromises = responderPhoneNumbers.map(toPhoneNumber => twilioHelpers.sendTwilioMessage(toPhoneNumber, deviceTwilioNumber, textMessage))

    const responses = await Promise.all(sendPromises)

    const failedResponses = responses.filter(response => !response)
    if (failedResponses.length > 0) {
      const errorMessage = `sendMessageToAllResponders: Failed to send ${failedResponses.length} messages out of ${responderPhoneNumbers.length}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    return responses
  } catch (error) {
    const errorMessage = `sendMessageToAllResponders: Error sending message: ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function updateSessionBasedOnEventType(eventType, messageKey, sessionId) {
  if (eventType === EVENT_TYPE.DURATION_ALERT || eventType === EVENT_TYPE.STILLNESS_ALERT) {
    await db_new.updateSession(sessionId, SESSION_STATUS.ACTIVE, false, false)
  } else if (eventType === EVENT_TYPE.DOOR_OPENED) {
    // If we get a door opened event, the session's door opened is toggled to true
    // This makes it so that server is able to create a new session
    const doorOpened = true
    const surveySent = !!(messageKey === 'stillnessAlertSurveyDoorOpened' || messageKey === 'durationAlertSurveyDoorOpened')
    await db_new.updateSession(sessionId, SESSION_STATUS.ACTIVE, doorOpened, surveySent)
  }
}

async function selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT: {
      if (eventData.numStillnessAlertsSent >= 1 && eventData.numStillnessAlertsSent <= 3) {
        return 'stillnessAlert'
      }
      if (eventData.numStillnessAlertsSent === 4) {
        return 'stillnessAlertFallback'
      }
      break
    }
    case EVENT_TYPE.DOOR_OPENED: {
      const latestAlertEvent = await db_new.getLatestAlertEvent(currentSession.sessionId, pgClient)
      if (!latestAlertEvent) {
        const errorMessage = `selectMessageKeyForExistingSession: No latest alert event found for session ID: ${currentSession.sessionId}`
        helpers.logError(errorMessage)
        throw new Error(errorMessage)
      }

      switch (latestAlertEvent.eventType) {
        case EVENT_TYPE.DURATION_ALERT:
          return 'durationAlertSurveyPromptDoorOpened'
        case EVENT_TYPE.STILLNESS_ALERT:
          return 'stillnessAlertSurveyDoorOpened'
        default: {
          const errorMessage = `selectMessageKeyForExistingSession: Invalid latest event type: ${latestAlertEvent.eventType} for session ID: ${currentSession.sessionId}`
          helpers.logError(errorMessage)
          throw new Error(errorMessage)
        }
      }
    }
    default: {
      const errorMessage = `selectMessageKeyForExistingSession: Invalid event type: ${eventType} for session ID: ${currentSession.sessionId}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
  }
}

async function handleExistingSession(device, eventType, eventData, currentSession, pgClient) {
  try {
    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const surveyCategories = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
      surveyCategories,
    })

    const fallbackPhoneNumbers = client.fallbackPhoneNumbers
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber

    // send message to responders only if survey is not already sent
    const surveySent = await db_new.getSessionSurveySent(currentSession.sessionId, pgClient)
    if (
      eventData.numStillnessAlertsSent === 4 &&
      messageKey === 'stillnessAlertFallback' &&
      fallbackPhoneNumbers &&
      fallbackPhoneNumbers.length > 0 &&
      !surveySent
    ) {
      await sendMessageToAllResponders(deviceTwilioNumber, fallbackPhoneNumbers, textMessage)
    } else if (!surveySent) {
      await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)
    }

    // update the session
    await updateSessionBasedOnEventType(eventType, messageKey, currentSession.sessionId)

    // log the event
    await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    const errorMessage = `handleExistingSession: Error handling existing session for device ID: ${
      device.deviceId
    }, event type: ${eventType}, event data: ${JSON.stringify(eventData)}, session ID: ${currentSession.sessionId} - ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function selectMessageKeyForNewSession(eventType) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'stillnessAlert'
    default: {
      const errorMessage = `selectMessageKeyForNewSession: Invalid event type received as the first alert: ${eventType}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
  }
}

async function handleNewSession(device, eventType, eventData, pgClient) {
  try {
    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession || !newSession.sessionId) {
      const errorMessage = `handleNewSession: Failed to create a new session for device ID: ${device.deviceId}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForNewSession(eventType)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
    })

    // send message to all responders
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)

    // log the event
    await db_new.createEvent(newSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    const errorMessage = `handleNewSession: Error handling new session for device ID: ${
      device.deviceId
    }, event type: ${eventType}, event data: ${JSON.stringify(eventData)} - ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function processSensorEvent(device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = 'processSensorEvent: Error starting transaction'
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    // A session is active if its session_status is ACTIVE and door_opened is false (closed).
    // If not, the server can create a new session.
    const currentSession = await db_new.getCurrentActiveSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) {
      await handleNewSession(device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(device, eventType, eventData, currentSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    const errorMessage = `processSensorEvent: Rolled back transaction because of error: ${error}`
    helpers.logError(errorMessage)
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        const rollbackErrorMessage = `processSensorEvent: Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`
        helpers.logError(rollbackErrorMessage)
        throw new Error(rollbackErrorMessage)
      }
    }
    throw new Error(errorMessage)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------
// Sensor Events (/api/sensorEvent)

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

function respondWithError(response, path, errorMessage) {
  helpers.logError(`Error on ${path}: ${errorMessage}`)
  // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
  response.status(200).json(errorMessage)
}

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      return respondWithError(response, request.path, `Bad request: ${validationErrors.array()}`)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body

    if (api_key !== particleWebhookAPIKey) {
      return respondWithError(response, request.path, 'Access not allowed')
    }

    // convert string to defined enum using map
    const eventTypeMapping = {
      'Duration Alert': EVENT_TYPE.DURATION_ALERT,
      'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
      'Door Opened': EVENT_TYPE.DOOR_OPENED,
    }

    const eventType = eventTypeMapping[receivedEventType]
    if (!eventType) {
      return respondWithError(response, request.path, `Unknown event type: ${receivedEventType}`)
    }

    // convert json string to object
    let eventData
    if (typeof receivedEventData !== 'string') {
      eventData = receivedEventData
    } else {
      try {
        eventData = JSON.parse(receivedEventData)
      } catch (error) {
        return respondWithError(response, request.path, `Error parsing eventData: ${error.toString()}`)
      }
    }

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      return respondWithError(response, request.path, `No device matches the coreID ${particleDeviceID}`)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      try {
        // if client and devices both are sending alerts
        await processSensorEvent(device, eventType, eventData)
      } catch (error) {
        return respondWithError(response, request.path, `Error processing sensor event: ${error.toString()}`)
      }
    }

    response.status(200).json('OK')
  } catch (error) {
    respondWithError(response, request.path, `Error processing request: ${error.toString()}`)
  }
}

// ----------------------------------------------------------------------------------------------------------------------------

module.exports = {
  validateTwilioRequest,
  handleTwilioRequest,
  validateSensorEvent,
  handleSensorEvent,
}
