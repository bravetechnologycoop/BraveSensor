/*
 * events.js
 *
 * Handles all types of events generated by sensors via particle webhooks at /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')
const i18next = require('i18next')
const twilio = require('twilio')

// In-house dependencies
const { helpers, twilioHelpers } = require('./utils/index')
const { EVENT_TYPE, SESSION_STATUS } = require('./enums/index')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')
const TWILIO_TOKEN = helpers.getEnvVar('TWILIO_TOKEN')

function validateTwilioRequest(request, response, next) {
  if (twilio.validateExpressRequest(request, TWILIO_TOKEN)) {
    next()
  } else {
    const errorMessage = `Bad request to ${request.path}: Sender ${request.body.From} is not Twilio`
    helpers.logError(errorMessage)
    response.status(401).send(errorMessage)
  }
}

// ------------------------------------------------------------------------------------------------
// Helper Handler Functions

async function sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, textMessage) {
  if (!deviceTwilioNumber || !responderPhoneNumber) {
    const errorMessage = 'sendMessageToResponder: Missing device twilio number or responder phone number'
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }

  try {
    const response = await twilioHelpers.sendTwilioMessage(responderPhoneNumber, deviceTwilioNumber, textMessage)

    if (!response) {
      const errorMessage = `sendMessageToResponder: Failed to send message to ${responderPhoneNumber}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    return response
  } catch (error) {
    helpers.logError(`sendMessageToResponder: Error sending message: ${error}`)
    throw error
  }
}

async function sendInvalidResponse(latestSession, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId)

  // set attending responder phone number if not already set
  if (!latestSession.attendingResponderNumber) {
    await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
  }

  // construct the try again message and send it to the attending phone
  const responseMessageKey = 'invalidResponseTryAgain'
  const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })
  await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
  await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

  // check if nonAttendingResponderConfirmation was sent
  const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
  const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })
  const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)
  const nonAttendingConfirmationSent = await db_new.checkEventExists(
    latestSession.sessionId,
    EVENT_TYPE.MSG_SENT,
    nonAttendingResponseMessageKey,
    pgClient,
  )
  if (!nonAttendingConfirmationSent) {
    for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
      await sendMessageToResponder(phoneNumber, deviceTwilioNumber, nonAttendingResponseMessage)
      await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
    }
  }
}

// ------------------------------------------------------------------------------------------------
// Incoming message handlers

async function handleDurationAlertSurveyPromptDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId)
  const clientLanguage = client.language || 'en'

  try {
    if (message === '0') {
      // set attending responder phone number if not already set
      if (!latestSession.attendingResponderNumber) {
        await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
      }
      await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyPromptDoorOpened', pgClient)

      // construct response message and send it to the attending phone
      const responseMessageKey = 'durationAlertSurveyDoorOpened'
      const surveyCategories = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
      const responseMessage = i18next.t(responseMessageKey, {
        lng: clientLanguage,
        surveyCategories,
      })
      await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
      await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

      // update the session survey sent
      await db_new.updateSession(latestSession.sessionId, SESSION_STATUS.ACTIVE, true, true, pgClient)

      // construct response message for non attending phones and send it
      const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
      const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })
      const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)
      const nonAttendingConfirmationSent = await db_new.checkEventExists(
        latestSession.sessionId,
        EVENT_TYPE.MSG_SENT,
        nonAttendingResponseMessageKey,
        pgClient,
      )
      if (!nonAttendingConfirmationSent) {
        for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
          await sendMessageToResponder(phoneNumber, deviceTwilioNumber, nonAttendingResponseMessage)
          await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
        }
      }
    } else {
      await sendInvalidResponse(latestSession, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
    }
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyPromptDoorOpened: Error handling message: ${error}`)
    throw error
  }
}

async function handleDurationAlertSurveyDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId)
  const clientLanguage = client.language || 'en'
  const surveyCategories = client.surveyCategories

  try {
    // Validate the message to ensure it's a valid index
    const messageIndex = parseInt(message, 10)
    if (messageIndex < 0 || messageIndex >= surveyCategories.length) {
      await sendInvalidResponse(latestSession, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
      return
    }

    // set attending responder phone number if not already set
    if (!latestSession.attendingResponderNumber) {
      await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
    }
    await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_RECEIVED, 'durationAlertSurveyDoorOpened', pgClient)

    // construct the response message and send it to the attending phone
    const selectedCategory = surveyCategories[messageIndex]
    let responseMessageKey

    switch (selectedCategory) {
      case 'Overdose Event':
      case 'Emergency Event':
      case 'Occupant Okay':
      case 'Space Empty':
        responseMessageKey = 'thankYou'
        break
      case 'Other':
        responseMessageKey = 'durationAlertSurveyOtherFollowup'
        break
      case 'I would like to contact Brave':
        responseMessageKey = 'braveContactInfo'
        break
      default:
        await sendInvalidResponse(latestSession, responderPhoneNumber, deviceTwilioNumber, clientLanguage, pgClient)
        return
    }
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })
    await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
    await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

    // update the session to be completed
    if (responseMessageKey === 'thankYou' || responseMessageKey === 'braveContactInfo') {
      await db_new.updateSession(latestSession.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)
    }

    // check if nonAttendingResponderConfirmation was sent
    const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
    const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })
    const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)
    const nonAttendingConfirmationSent = await db_new.checkEventExists(
      latestSession.sessionId,
      EVENT_TYPE.MSG_SENT,
      nonAttendingResponseMessageKey,
      pgClient,
    )
    if (!nonAttendingConfirmationSent) {
      for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
        await sendMessageToResponder(phoneNumber, deviceTwilioNumber, nonAttendingResponseMessage)
        await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
      }
    }
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyDoorOpened: Error handling message: ${error}`)
    throw error
  }
}

async function handleDurationAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const client = await db_new.getClientWithDeviceId(latestSession.deviceId)
  const clientLanguage = client.language || 'en'

  try {
    // set attending responder phone number if not already set
    if (!latestSession.attendingResponderNumber) {
      await db_new.updateSessionAttendingResponder(latestSession.sessionId, responderPhoneNumber, pgClient)
    }
    const eventTypeDetails = `durationAlertSurveyOtherFollowup: ${message}`
    await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_RECEIVED, eventTypeDetails, pgClient)

    // construct the response message and send it to the attending phone
    const responseMessageKey = 'thankYou'
    const responseMessage = i18next.t(responseMessageKey, { lng: clientLanguage })
    await sendMessageToResponder(responderPhoneNumber, deviceTwilioNumber, responseMessage)
    await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, responseMessageKey, pgClient)

    // update the session to be completed
    await db_new.updateSession(latestSession.sessionId, SESSION_STATUS.COMPLETED, true, true, pgClient)

    // check if nonAttendingResponderConfirmation was sent
    const nonAttendingResponseMessageKey = 'nonAttendingResponderConfirmation'
    const nonAttendingResponseMessage = i18next.t(nonAttendingResponseMessageKey, { lng: clientLanguage })
    const nonAttendingResponderPhoneNumbers = client.responderPhoneNumbers.filter(phoneNumber => phoneNumber !== responderPhoneNumber)
    const nonAttendingConfirmationSent = await db_new.checkEventExists(
      latestSession.sessionId,
      EVENT_TYPE.MSG_SENT,
      nonAttendingResponseMessageKey,
      pgClient,
    )
    if (!nonAttendingConfirmationSent) {
      for (const phoneNumber of nonAttendingResponderPhoneNumbers) {
        await sendMessageToResponder(phoneNumber, deviceTwilioNumber, nonAttendingResponseMessage)
        await db_new.createEvent(latestSession.sessionId, EVENT_TYPE.MSG_SENT, nonAttendingResponseMessageKey, pgClient)
      }
    }
  } catch (error) {
    helpers.logError(`handleDurationAlertSurveyOtherFollowup: Error handling message: ${error}`)
    throw error
  }
}

async function handleStillnessAlert(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  helpers.log(
    `handleStillnessAlert called with parameters: latestSession=${JSON.stringify(
      latestSession,
    )}, responderPhoneNumber=${responderPhoneNumber}, deviceTwilioNumber=${deviceTwilioNumber}, message=${message}, pgClient=${pgClient}`,
  )
}

async function handleStillnessAlertSurvey(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  helpers.log(
    `handleStillnessAlertSurvey called with parameters: latestSession=${JSON.stringify(
      latestSession,
    )}, responderPhoneNumber=${responderPhoneNumber}, deviceTwilioNumber=${deviceTwilioNumber}, message=${message}, pgClient=${pgClient}`,
  )
}

async function handleStillnessAlertSurveyDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  helpers.log(
    `handleStillnessAlertSurveyDoorOpened called with parameters: latestSession=${JSON.stringify(
      latestSession,
    )}, responderPhoneNumber=${responderPhoneNumber}, deviceTwilioNumber=${deviceTwilioNumber}, message=${message}, pgClient=${pgClient}`,
  )
}

async function handleStillnessAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  helpers.log(
    `handleStillnessAlertSurveyOtherFollowup called with parameters: latestSession=${JSON.stringify(
      latestSession,
    )}, responderPhoneNumber=${responderPhoneNumber}, deviceTwilioNumber=${deviceTwilioNumber}, message=${message}, pgClient=${pgClient}`,
  )
}

async function handleStillnessAlertSurveyOccupantOkayFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  helpers.log(
    `handleStillnessAlertSurveyOccupantOkayFollowup called with parameters: latestSession=${JSON.stringify(
      latestSession,
    )}, responderPhoneNumber=${responderPhoneNumber}, deviceTwilioNumber=${deviceTwilioNumber}, message=${message}, pgClient=${pgClient}`,
  )
}

async function handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient) {
  const latestRespondableEventDetails = latestRespondableEvent.eventTypeDetails

  switch (latestRespondableEventDetails) {
    case 'durationAlertSurveyPromptDoorOpened':
      await handleDurationAlertSurveyPromptDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'durationAlertSurveyDoorOpened':
      await handleDurationAlertSurveyDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'durationAlertSurveyOtherFollowup':
      await handleDurationAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'stillnessAlert':
      await handleStillnessAlert(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'stillnessAlertSurvey':
      await handleStillnessAlertSurvey(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'stillnessAlertSurveyDoorOpened':
      await handleStillnessAlertSurveyDoorOpened(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'stillnessAlertSurveyOtherFollowup':
      await handleStillnessAlertSurveyOtherFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    case 'stillnessAlertSurveyOccupantOkayFollowup':
      await handleStillnessAlertSurveyOccupantOkayFollowup(latestSession, responderPhoneNumber, deviceTwilioNumber, message, pgClient)
      break
    default: {
      const errorMessage = `Unhandled event type: ${latestRespondableEventDetails}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
  }
}

async function handleTwilioRequest(request, response) {
  let pgClient

  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      const errorMessage = `Bad request: ${validationErrors.array()}`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const requiredBodyParams = ['Body', 'From', 'To']
    if (!helpers.isValidRequest(request, requiredBodyParams)) {
      const errorMessage = `Bad request to ${request.path}: Body, From, or To fields are missing`
      helpers.logError(errorMessage)
      response.status(400).send(errorMessage)
      return
    }

    const responderPhoneNumber = request.body.From
    const deviceTwilioNumber = request.body.To
    const message = request.body.Body

    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = 'Failed to start database transaction'
      helpers.logError(errorMessage)
      response.status(500).send(errorMessage)
      return
    }

    try {
      // Get the latest session for the device
      const latestSession = await db_new.getLatestSession(deviceTwilioNumber, pgClient)
      if (!latestSession) {
        const errorMessage = `No session found for device: ${deviceTwilioNumber}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      // Get the latest respondable event for the session
      // Respondable events are the events that the server expects a response too
      // These are certain events identified by their event details and are handled in handleIncomingMessage
      const latestRespondableEvent = await db_new.getLatestRespondableEvent(latestSession.sessionId, pgClient)
      if (!latestRespondableEvent) {
        const errorMessage = `No event found for session: ${latestSession.sessionId}`
        helpers.logError(errorMessage)
        response.status(404).send(errorMessage)
        return
      }

      await handleIncomingMessage(latestSession, latestRespondableEvent, responderPhoneNumber, deviceTwilioNumber, message, pgClient)

      await db_new.commitTransaction(pgClient)
      response.status(200).send()
    } catch (error) {
      helpers.logError(`handleTwilioRequest: Rolled back transaction because of error: ${error}`)
      await db_new.rollbackTransaction(pgClient)
      response.status(500).send(error.toString())
    }
  } catch (error) {
    helpers.logError(error)
    response.status(500).send(error.toString())
  }
}

// ------------------------------------------------------------------------------------------------

async function sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage) {
  if (!deviceTwilioNumber || !Array.isArray(responderPhoneNumbers) || responderPhoneNumbers.length === 0) {
    const errorMessage = 'sendMessageToAllResponders: Missing device Twilio number or responder phone numbers'
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }

  try {
    const sendPromises = responderPhoneNumbers.map(toPhoneNumber => twilioHelpers.sendTwilioMessage(toPhoneNumber, deviceTwilioNumber, textMessage))

    const responses = await Promise.all(sendPromises)

    const failedResponses = responses.filter(response => !response)
    if (failedResponses.length > 0) {
      const errorMessage = `sendMessageToAllResponders: Failed to send ${failedResponses.length} messages out of ${responderPhoneNumbers.length}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    return responses
  } catch (error) {
    const errorMessage = `sendMessageToAllResponders: Error sending message: ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function updateSessionBasedOnEventType(eventType, messageKey, sessionId) {
  if (eventType === EVENT_TYPE.DURATION_ALERT || eventType === EVENT_TYPE.STILLNESS_ALERT) {
    await db_new.updateSession(sessionId, SESSION_STATUS.ACTIVE, false, false)
  } else if (eventType === EVENT_TYPE.DOOR_OPENED) {
    // If we get a door opened event, the session's door opened is toggled to true
    // This makes it so that server is able to create a new session
    const doorOpened = true
    const surveySent = !!(messageKey === 'stillnessAlertSurveyDoorOpened' || messageKey === 'durationAlertSurveyDoorOpened')
    await db_new.updateSession(sessionId, SESSION_STATUS.ACTIVE, doorOpened, surveySent)
  }
}

async function selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT: {
      if (eventData.numStillnessAlertsSent >= 1 && eventData.numStillnessAlertsSent <= 3) {
        return 'stillnessAlert'
      }
      if (eventData.numStillnessAlertsSent === 4) {
        return 'stillnessAlertFallback'
      }
      const errorMessage = `selectMessageKeyForExistingSession: Too many stillness alerts sent: ${eventData.numStillnessAlertsSent} for session ID: ${currentSession.sessionId}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
    case EVENT_TYPE.DOOR_OPENED: {
      const latestAlertEvent = await db_new.getLatestAlertEvent(currentSession.sessionId, pgClient)
      if (!latestAlertEvent) {
        const errorMessage = `selectMessageKeyForExistingSession: No latest alert event found for session ID: ${currentSession.sessionId}`
        helpers.logError(errorMessage)
        throw new Error(errorMessage)
      }

      switch (latestAlertEvent.eventType) {
        case EVENT_TYPE.DURATION_ALERT:
          return 'durationAlertSurveyPromptDoorOpened'
        case EVENT_TYPE.STILLNESS_ALERT:
          return 'stillnessAlertSurveyDoorOpened'
        default: {
          const errorMessage = `selectMessageKeyForExistingSession: Invalid latest event type: ${latestAlertEvent.eventType} for session ID: ${currentSession.sessionId}`
          helpers.logError(errorMessage)
          throw new Error(errorMessage)
        }
      }
    }
    default: {
      const errorMessage = `selectMessageKeyForExistingSession: Invalid event type: ${eventType} for session ID: ${currentSession.sessionId}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
  }
}

async function handleExistingSession(device, eventType, eventData, currentSession, pgClient) {
  try {
    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForExistingSession(eventType, eventData, currentSession, pgClient)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const surveyCategories = client.surveyCategories.map((category, index) => `${index}: ${category}`).join('\n')
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
      surveyCategories,
    })

    helpers.log(textMessage)

    // send message to responders
    const fallbackPhoneNumbers = client.fallbackPhoneNumbers
    const responderPhoneNumbers = client.responderPhoneNumbers
    const deviceTwilioNumber = device.deviceTwilioNumber
    if (
      eventData.numStillnessAlertsSent === 4 &&
      messageKey === 'stillnessAlertFallback' &&
      fallbackPhoneNumbers &&
      fallbackPhoneNumbers.length > 0
    ) {
      await sendMessageToAllResponders(deviceTwilioNumber, fallbackPhoneNumbers, textMessage)
    } else {
      await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)
    }

    // update the session
    await updateSessionBasedOnEventType(eventType, messageKey, currentSession.sessionId)

    // log the event
    await db_new.createEvent(currentSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    const errorMessage = `handleExistingSession: Error handling existing session for device ID: ${
      device.deviceId
    }, event type: ${eventType}, event data: ${JSON.stringify(eventData)}, session ID: ${currentSession.sessionId} - ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function selectMessageKeyForNewSession(eventType) {
  switch (eventType) {
    case EVENT_TYPE.DURATION_ALERT:
      return 'durationAlert'
    case EVENT_TYPE.STILLNESS_ALERT:
      return 'stillnessAlert'
    default: {
      const errorMessage = `selectMessageKeyForNewSession: Invalid event type received as the first alert: ${eventType}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }
  }
}

async function handleNewSession(device, eventType, eventData, pgClient) {
  try {
    // create a new active session
    const newSession = await db_new.createSession(device.deviceId, pgClient)
    if (!newSession || !newSession.sessionId) {
      const errorMessage = `handleNewSession: Failed to create a new session for device ID: ${device.deviceId}`
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    // find messageKey based on eventType
    const messageKey = await selectMessageKeyForNewSession(eventType)

    // construct translated textMessage
    const client = await db_new.getClientWithClientId(device.clientId)
    const clientLanguage = client.language || 'en'
    const textMessage = i18next.t(messageKey, {
      lng: clientLanguage,
      deviceName: device.displayName,
      occupancyDuration: eventData.occupancyDuration,
    })

    helpers.log(textMessage)

    // send message to all responders
    // const responderPhoneNumbers = client.responderPhoneNumbers
    // const deviceTwilioNumber = device.deviceTwilioNumber
    // await sendMessageToAllResponders(deviceTwilioNumber, responderPhoneNumbers, textMessage)

    // log the event
    await db_new.createEvent(newSession.sessionId, eventType, messageKey, pgClient)
  } catch (error) {
    const errorMessage = `handleNewSession: Error handling new session for device ID: ${
      device.deviceId
    }, event type: ${eventType}, event data: ${JSON.stringify(eventData)} - ${error}`
    helpers.logError(errorMessage)
    throw new Error(errorMessage)
  }
}

async function processSensorEvent(device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (!pgClient) {
      const errorMessage = 'processSensorEvent: Error starting transaction'
      helpers.logError(errorMessage)
      throw new Error(errorMessage)
    }

    // An active session is one that has status ACTIVE and door is not opened
    // If either of those are violated, server can create a new session
    const currentSession = await db_new.getCurrentActiveSessionWithDeviceId(device.deviceId, pgClient)
    if (!currentSession) {
      await handleNewSession(device, eventType, eventData, pgClient)
    } else {
      await handleExistingSession(device, eventType, eventData, currentSession, pgClient)
    }

    await db_new.commitTransaction(pgClient)
  } catch (error) {
    const errorMessage = `processSensorEvent: Rolled back transaction because of error: ${error}`
    helpers.logError(errorMessage)
    if (pgClient) {
      try {
        await db_new.rollbackTransaction(pgClient)
      } catch (rollbackError) {
        const rollbackErrorMessage = `processSensorEvent: Error rolling back transaction: ${rollbackError}. Rollback attempted because of error: ${error}`
        helpers.logError(rollbackErrorMessage)
        throw new Error(rollbackErrorMessage)
      }
    }
    throw new Error(errorMessage)
  }
}

// ------------------------------------------------------------------------------------------------

function respondWithError(response, errorMessage, path) {
  helpers.logError(`Error on ${path}: ${errorMessage}`)
  // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
  response.status(200).json(errorMessage)
}

function getEventType(receivedEventType, response, path) {
  // Map event type from string to enum
  const eventTypeMapping = {
    'Duration Alert': EVENT_TYPE.DURATION_ALERT,
    'Stillness Alert': EVENT_TYPE.STILLNESS_ALERT,
    'Door Opened': EVENT_TYPE.DOOR_OPENED,
  }

  const eventType = eventTypeMapping[receivedEventType]
  if (!eventType) {
    respondWithError(response, `Unknown event type: ${receivedEventType}`, path)
  }

  return eventType
}

function parseEventData(receivedEventData, response, path) {
  if (typeof receivedEventData !== 'string') return receivedEventData
  try {
    // Parse event data from string to JSON
    return JSON.parse(receivedEventData)
  } catch (error) {
    respondWithError(response, `Error parsing eventData: ${error.toString()}`, path)
    return null
  }
}

const validateSensorEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

async function handleSensorEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)
    if (!validationErrors.isEmpty()) {
      return respondWithError(response, `Bad request: ${validationErrors.array()}`, request.path)
    }

    const { api_key, event: receivedEventType, data: receivedEventData, coreid: particleDeviceID } = request.body

    if (api_key !== particleWebhookAPIKey) {
      return respondWithError(response, `Access not allowed`, request.path)
    }

    const eventType = getEventType(receivedEventType, response, request.path)
    if (!eventType) return
    const eventData = parseEventData(receivedEventData, response, request.path)
    if (!eventData) return

    const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
    if (!device) {
      return respondWithError(response, `No device matches the coreID ${particleDeviceID}`, request.path)
    }

    const client = await db_new.getClientWithClientId(device.clientId)
    if (client.devicesSendingAlerts && device.isSendingAlerts) {
      // process the sensor event if alerts are enabled
      try {
        await processSensorEvent(device, eventType, eventData)
      } catch (error) {
        return respondWithError(response, `Error processing sensor event: ${error.toString()}`, request.path)
      }
    }

    response.status(200).json('OK')
  } catch (error) {
    respondWithError(response, `Error processing request: ${error.toString()}`, request.path)
  }
}

// ------------------------------------------------------------------------------------------------

module.exports = {
  validateSensorEvent,
  validateTwilioRequest,
  handleSensorEvent,
  handleTwilioRequest,
}
