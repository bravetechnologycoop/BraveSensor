/*
 * events.js
 *
 * Handles all types of events generated by particle webhooks on /api/sensorEvent
 */

// Third-party dependencies
const Validator = require('express-validator')

// In-house dependencies
const { helpers } = require('./utils/index')
const { EVENT_TYPE } = require('./enums/index')
const db_new = require('./db/db_new')

const particleWebhookAPIKey = helpers.getEnvVar('PARTICLE_WEBHOOK_API_KEY')

async function handleAlert(device, eventType, eventData) {
  let pgClient

  try {
    pgClient = await db_new.beginTransaction()
    if (pgClient === null) {
      helpers.logError(`handleAlert: Error starting transaction`)
      return
    }

    helpers.log(device)
    helpers.log(eventType)
    helpers.log(eventData)

    // const currentTime = await db_new.getCurrentTime(pgClient)
    // const currentSession = await db_new.getSessionWithDeviceId(device.deviceId, pgClient)

    // if there is no session, then this is the first event
    // if (currentSession === null) {
    // double check to make sure the message is either a duration or a stillness
    // those are the only two option to create a new session

    // create an active session and log the event
    // const newSession = await db_new.createSession(device.device_id, pgClient)
    // await db_new.createEvent(newSession.sessionId, eventType, pgClient)

    // send the message to the client
    // 1. construct the message
    // 2. translate the message (use clientId to figure out the client and language)
    // 3. send the message to all the responder clients using device_twilio_phone_number

    // let textMessage = ''
    // if (alertType === ALERT_TYPE.SENSOR_DURATION) {
    //   textMessage = `${location.displayName} has been occupied for ${alertData.occupancyTime} minutes`
    // } else if (alertType === ALERT_TYPE.SENSOR_STILLNESS) {
    //   textMessage = `${location.displayName} needs a SAFETY CHECK. On your way? Reply with anything`
    // } else {
    //   helpers.logError('Invalid alert type received as the first alert')
    // }

    // let response
    // try {
    //   const fromPhoneNumber = location.fromPhoneNumber
    //   const responderPhoneNumbers = client.responderPhoneNumbers
    //   const hasValidPhoneNumbers = fromPhoneNumber && responderPhoneNumbers && responderPhoneNumbers.length > 0

    //   if (hasValidPhoneNumbers) {
    //     const messagePromises = responderPhoneNumbers.map(toPhoneNumber =>
    //       twilioHelpers.sendTwilioMessage(toPhoneNumber, fromPhoneNumber, textMessage),
    //     )
    //     response = await Promise.all(messagePromises)
    //   }
    // } catch (error) {
    //   helpers.logError(error)
    // }

    // // handle invalid response (all promises are resolved)
    // const isResponseInvalid = response === undefined || (Array.isArray(response) && response.every(result => result === undefined))
    // if (isResponseInvalid) {
    //   helpers.logError(`Failed to send alert update for session ${newSession.id}: ${textMessage}`)
    // }
    // }
    // // otherwise, the session already exist
    // else {
    //   // if the alert recived was a door opened alert,
    //   // then update the session door_opened_at to current time
    //   // if (alertType === SENSOR_EVENT.DOOR_OPENED) {
    //   //   // update the existing session
    //   //   await db.updateSession(
    //   //     currentSession.id, // session will be identified by this
    //   //     currentTime, // updated_at
    //   //     currentTime, // door_opened_at
    //   //     pgClient, // pg database instance
    //   //   )
    //   // } else {
    //   //   // otherwise if it was another duration or stillness alert
    //   //   // update the existing session
    //   //   await db.updateSession(
    //   //     currentSession.id, // session will be identified by this
    //   //     currentTime, // updated_at
    //   //     pgClient, // pg database instance
    //   //   )
    //   // }
    //   // // push the alert to the alerts table
    //   // await db.createAlert(
    //   //   currentSession.id, // foriegn key session id
    //   //   alertType, // alert type
    //   //   currentTime, // recieved_at
    //   //   pgClient, // pg database instance
    //   // )
    // }

    await db_new.commitTransaction(pgClient)
  } catch (e) {
    try {
      await db_new.rollbackTransaction(pgClient)
      helpers.logError(`handleAlert: Rolled back transaction because of error: ${e}`)
    } catch (error) {
      helpers.logError(`handleAlert: Error rolling back transaction: ${error} Rollback attempted because of error: ${e}`)
    }
  }
}

const validateEvent = Validator.body(['event', 'data', 'coreid', 'api_key']).exists()

async function handleEvent(request, response) {
  try {
    const validationErrors = Validator.validationResult(request).formatWith(helpers.formatExpressValidationErrors)

    if (validationErrors.isEmpty()) {
      const apiKey = request.body.api_key

      if (particleWebhookAPIKey === apiKey) {
        const receivedEventType = request.body.event
        const eventData = request.body.data
        const particleDeviceID = request.body.coreid

        let eventType
        switch (receivedEventType) {
          case 'Duration Alert': {
            eventType = EVENT_TYPE.DURATION_ALERT
            break
          }
          case 'Stillness Alert': {
            eventType = EVENT_TYPE.STILLNESS_ALERT
            break
          }
          case 'Door Opened': {
            eventType = EVENT_TYPE.DOOR_OPENED
            break
          }
          default: {
            const errorMessage = `Bad request to ${request.path}: unknown event type ${receivedEventType}`
            helpers.logError(errorMessage)
            response.status(200).json(errorMessage)
            return
          }
        }

        const device = await db_new.getDeviceWithParticleDeviceId(particleDeviceID)
        if (!device) {
          const errorMessage = `Bad request to ${request.path}: no device matches the coreID ${particleDeviceID}`
          helpers.logError(errorMessage)
          // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
          response.status(200).json(errorMessage)
        } else {
          const client = await db_new.getClientWithClientId(device.clientId)
          if (client.devicesSendingAlerts && device.isSendingAlerts) {
            await handleAlert(device, eventType, eventData)
          }
          response.status(200).json('OK')
        }
      } else {
        const errorMessage = `Access not allowed`
        helpers.logError(errorMessage)
        // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
        response.status(200).json(errorMessage)
      }
    } else {
      const errorMessage = `Bad request to ${request.path}: ${validationErrors.array()}`
      helpers.logError(errorMessage)
      // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
      response.status(200).json(errorMessage)
    }
  } catch (err) {
    const errorMessage = `Error calling ${request.path}: ${err.toString()}`
    helpers.logError(errorMessage)
    // Must send 200 so as not to be throttled by Particle (ref: https://docs.particle.io/reference/device-cloud/webhooks/#limits)
    response.status(200).json(errorMessage)
  }
}

module.exports = {
  validateEvent,
  handleEvent,
}
